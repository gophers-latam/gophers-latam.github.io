{"results":[{"href":"https://gophers-latam.github.io/posts/2021/04/cuarto-post/","title":"Cuarto Post","body":"Aquí hay fotos para post de prueba en modo: page bundle content.\nUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nImagenes post procesadas para reducir tamaño con shortcode layout.\n Rushmore   Badlands   National Park "},{"href":"https://gophers-latam.github.io/search/","title":"Búsqueda","body":""},{"href":"https://gophers-latam.github.io/posts/2021/04/tercer-post/","title":"Tercer Post","body":"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\nUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n"},{"href":"https://gophers-latam.github.io/posts/2021/04/segundo-post/","title":"Segundo Post","body":"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\nUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n"},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-resumen-reglas/","title":"Golang: Resumen reglas","body":" Go Police  El lenguaje de programación Go fue creado para hacer el trabajo fácilmente.\nGo tiene conceptos similares a los lenguajes imperativos y el tipado estático. También es rápido en la compilación, rápido de ejecutar e implementar. Grande y complejo.\nEn este post, se explican conceptos básicos de Go tratando algunos conceptos o reglas importantes.\nLos principales temas tratados son los siguientes:\n Escribir comentarios. Librerías e importación. Funciones. Tipos de datos. Valores de retorno con nombre. Variables y memoria. Control de sentencias. Generar funciones. Ejecución diferida. Interfaces. Múltiples entradas. Manejo de errores. Ejecución simultánea.  Escribir comentarios: Para escribir un comentario de una línea\n// comentario de una sola línea Escribir un comentario con más de una línea\n/* comentario de multi-línea */ Librerías e importación: Cada archivo de código fuente comienza con la palabra clave package. La palabra clave main se utiliza para identificar el archivo como un archivo operativo, no como una librería.\npackage main Para importar un paquete de la librería estándar, terceros o personal al archivo, usamos la instrucción import de la siguiente manera:\nimport ( \u0026#34;fmt\u0026#34; // paquete en la librería estándar  \u0026#34;io/ioutil\u0026#34; // se aplican funciones de E/S  m \u0026#34;math\u0026#34; // usando la letra m para acortar o hacer alias del nombre de la librería de funciones matemáticas  \u0026#34;net/http\u0026#34; // web server  \u0026#34;os\u0026#34; // funciones a nivel del sistema operativo, como el manejo de archivos  \u0026#34;strconv\u0026#34; // conversiones de texto ) Funciones: Las funciones se definen mediante la palabra func seguida del nombre de la función.\nLa función main es privada y es la entrada al archivo ejecutable del programa (Go usa llaves ornamentadas {} para definir partes / bloques).\nfunc main() { // salida de texto en la unidad main en stdout (salida estandar) con Println de fmt (stdlib pkg)  fmt.Println (\u0026#34;Hello world!\u0026#34;) // llamar a una función del paquete actual  beyondHello() } Las funciones necesitan paréntesis que reciben parámetros, e incluso en ausencia de parámetros, se requieren paréntesis.\nfunc beyondHello() { // declaración de variable (la variable debe declararse antes de usarse)  var x int // dar valor a la variable  x = 3 // definición corta usando := incluye definición de variable, especificando su tipo y dándole valor  y := 4 // una función que devuelve dos valores separados  sum, prod := learnMultiple (x, y) // imprimir salida de forma sencilla y directa  fmt.Println (\u0026#34;sum:\u0026#34;, sum, \u0026#34;prod:\u0026#34;, prod) learnTypes() } La definición de función puede tener múltiples coeficientes y valores de retorno. Por ejemplo, learnMultiple toma los coeficientes x, y \u0026hellip; y devuelve dos valores de sum y prod de tipo Int.\nfunc learnMultiple (x, y int) (sum, prod int) { // separar los valores devueltos con una coma regular return x + y, x * y } Tipos de datos: func learnTypes() { // las declaraciones cortas generalmente cumplen el propósito deseado  // definir una variable de texto usando comillas dobles  str := \u0026#34;Learn Go!\u0026#34; // definir una variable de texto con comillas simples  s2 := `A \u0026#34;raw\u0026#34; string literal can include line breaks.` // definir variable tipo runa que es otro nombre para el tipo int32 que contiene unicode  g := \u0026#39;Σ\u0026#39; // float  f := 3.14195 // definición de número complejo (Complex)  c := 3 + 4i // definir variables usando var  var u uint = 7 // número natural (entero positivo)  var pi float32 = 22. / 7 // un decimal de 32 bits  // definición corta byte (es otro nombre para uint8)  n := byte (\u0026#39;\\n\u0026#39;) // arrays tienen un tamaño fijo, y son fijos en momento de compilación  // definir un array int de 4 elementos con un valor inicial de cero  var a4 [4] int // definir un array de 3 elementos con valores 3, 1 y 5  a3 := [...] int {3, 1, 5} Go ofrece un tipo de datos llamado Slices. Los Slices entendibles como \u0026ldquo;rebanadas\u0026rdquo;, \u0026ldquo;porciones\u0026rdquo;, \u0026ldquo;segmentos\u0026rdquo; tienen un tamaño dinámico. Las matrices (array) y los segmentos (slice) tienen ventajas, pero los casos de uso de los segmentos son más comunes. La siguiente instrucción define un segmento de tipo int\n// observar la diferencia entre el array y la declaración del slice, donde cuando  // el slice está definido no hay un número que determine su tamaño  s3: = [] int {4, 5, 9} // definir un tipo int con cuatro elementos con valores cero  s4: = make ([] int, 4) // solo definir, y no hay selección  var d2 [] [] float64 // método para convertir el tipo de texto en slice  bs: = [] byte (\u0026#34;a slice\u0026#34;) Por la naturaleza de los slice dinámicos, es posible agregar nuevos elementos usando la función append incorporada. Primero se pasa el slice al que queremos agregar y luego los elementos que queremos agregar.\ns := [] int {1, 2, 3} s = append (s, 4, 5, 6) // se imprimirá un slice con el siguiente contenido [1 2 3 4 5 6]  fmt.Println (s) Para agregar un slice a otro slice, pasamos los dos slices en la función en lugar de pasar elementos individuales, y siguiendo el segundo slice con tres puntos.\ns = append (s, [] int {7, 8, 9} ...) // se imprimirá un slice con el siguiente contenido [1 2 3 4 5 6 7 8 9]  fmt.Println (s) La siguiente instrucción define las variables p y q como punteros en dos variables de tipo int que contienen dos valores devueltos por la función learnMemory:\np, q := learnMemory() // tema de reglas por ver Cuando un asterisco precede a un cursor, significa el valor de la variable a la que se refiere el cursor, como en el siguiente ejemplo los valores de las dos variables devueltas por la función learnMemory:\nfmt.Println (*p, *q) Los mapas (maps) en Go son arrays dinámicos y modificables que son similares al tipo de diccionario o hash en otros lenguajes.\n// aquí un mapa cuya clave es tipo texto y los valores de los elementos numéricos.  m: = map [string] int {\u0026#34;three\u0026#34;: 3, \u0026#34;four\u0026#34;: 4} m [\u0026#34;one\u0026#34;] = 1 Las variables no utilizadas son errores. El subrayado, guion bajo, operador blanco o Blank Identifier de la siguiente manera hace usar la variable pero ignora valores al mismo tiempo:\n_, _, _, _, _, _, _, _, _, _ = str, s2, g, f, u, pi, n, a3, s4, bs Valores de retorno con nombre: A diferencia de otros lenguajes, las funciones pueden tener valores de retorno con nombre. Donde el nombre se devuelve al valor de la función en la línea de la definición de la función, esta característica permite regresar fácilmente desde cualquier punto de la función además del uso de la palabra return solo sin mencionar nada después:\nfunc learnNamedReturns (x, y int) (z int) { z = x * y // aquí implícitamente significa devolver el valor de la variable z  return } Nota: El lenguaje Go se basa en gran medida en la recolección de basura. Go tiene indicadores pero no cálculos (puede confundir un cursor vacío, pero no puede aumentar el cursor). Tener cuidado con valores de retorno de nil pointer reference.\nVariables y memoria: Las variables p y q a continuación son indicadores del tipo int y representan valores de retorno en la función. Cuando se define, los cursores están vacíos; sin embargo, el uso de la función incorporada new hace que el valor de la variable numérica p se refiera a cero, y por lo tanto ocupa espacio en la memoria; es decir, p ya no está vacío.\nfunc learnMemory() (p, q* int) { p = new(int) // definir un slice de 20 elementos como una sola unidad en la memoria.  s := make([] int, 20) // dar valor a un elemento  s[3] = 7 // definir una nueva variable local a nivel de función  r := -2 // devolver dos valores de la función, que son direcciones de memoria  // para las variables s y r, respectivamente.  return \u0026amp;s[3], \u0026amp;r } func expensiveComputation() float64 { return m.Exp (10) } Control de sentencias Las sentencias condicionales requieren corchetes ornamentados y no requieren paréntesis.\nfunc learnFlowControl() { if true {fmt.Println (\u0026#34;told ya\u0026#34; ) } if false { // Rusters. } else { // Gophers. } Usar la instrucción switch si se necesita escribir más de una secuencia condicional.\nx := 42.0 switch x { case 0: case 1: case 42: case 43: default: } Como sentencia condicional, la cláusula for no toma paréntesis. Las variables definidas en la cláusula for son visibles a nivel de la sentencia.\nfor x: = 0; x \u0026lt;3; x ++ { fmt.Println (\u0026#34;iteration\u0026#34;, x) } La instrucción for es la única instrucción de iteración en el lenguaje Go y tiene otra formas, de la siguiente manera:\n// repetición infinita for { // break para detener la repetición  break // continue para ir a la siguiente iteración  continue } Se puede utilizar el range para pasar elementos de array, slice, text string, map, channel.\nEl range de canal (channel) devuelve un valor, y dos valores cuando se usa en slice, array, text string, o map.\n// ejemplo: for key, value := range map [string] int {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} { // imprimir el valor de cada elemento del mapa  fmt.Printf (\u0026#34;key =% s, value =% d \\n\u0026#34;, key, value) } Usar el guión bajo (_) contra valor de retorno en la clave si solo se desea el valor, de la siguiente manera:\nfor _, name: = range [] string {\u0026#34;Bob\u0026#34;, \u0026#34;Bill\u0026#34;, \u0026#34;Joe\u0026#34;} { fmt.Printf (\u0026#34;Hello,% s \\n\u0026#34;, name) } Se puede usar la declaración corta con la sentencia condicional para que se defina una variable y luego se verifique en la sentencia de condición.\nPor ejemplo se define una variable y, se le da un valor y luego se coloca la condición de la sentencia para que estén separadas por un punto y coma.\nif y := expensiveComputation(); y \u0026gt; x { x = y } Se puede definir funciones anónimas falsas directamente en el código.\nxBig := func() bool { // x:= 42 que fue declarada antes donde de menciona la sentencia switch  return x \u0026gt; 10000 } x = 99999 // la función xBig ahora devuelve el valor verdadero  fmt.Println (\u0026#34;xBig:\u0026#34;, xBig()) x = 1.3e3 // Después de modificar el valor de x a 1.3e3 que es igual a 1300 (es decir, mayor que 1000)  // la función xBig devuelve falso  fmt.Println (\u0026#34;xBig:\u0026#34;, xBig()) Además de lo anterior, es posible definir función fantasma y llamarla en la misma línea y pasarla a otra función siempre que se llame directamente y el tipo de resultado sea consistente con lo esperado en el parámetro de la función.\nfmt.Println (\u0026#34;Add + double two numbers:\u0026#34;, func (a, b int) int { return (a + b) * 2 } (10, 2)) goto love love: learnFunctionFactory() // Una función que devuelve una función  learnDefer() // Dormir  learnInterfaces() // Trabajar con interfaces } Generar funciones Se puede tratar las funciones como objetos separados. Por ejemplo, crear una función y el valor de retorno es otra.\nfunc learnFunctionFactory() { Los dos métodos siguientes para imprimir la oración son iguales, pero el segundo método es más claro, más legible y común.\nfmt.Println(sentenceFactory (\u0026#34;summer\u0026#34;) (\u0026#34;A beautiful\u0026#34;, \u0026#34;day!\u0026#34;)) d: = sentenceFactory (\u0026#34;summer\u0026#34;) fmt.Println(d (\u0026#34;A beautiful\u0026#34;, \u0026#34;day!\u0026#34;)) fmt.Println(d (\u0026#34;A lazy\u0026#34;, \u0026#34;afternoon!\u0026#34;)) } Los decoradores se encuentran en algunos lenguajes de programación y en el mismo concepto en Go para que poder pasar datos a funciones.\nfunc sentenceFactory(mystring string) func(before, after string) string { return func(before, after string) string { return fmt.Sprintf (\u0026#34;%s %s %s\u0026#34;, before, mystring, after) } } Ejecución diferida Se puede usar la función defer en funciones para realizar una acción antes de devolver el valor o resolver la funcion, y si se escribe más de una, el orden en ejecución de estas acciones es la contraria, como en learnDefer:\nfunc learnDefer() (ok bool) { // instrucciones diferidas se ejecutan antes de que la función devuelva el resultado.  defer fmt.Println (\u0026#34;deferred statements execute in reverse (LIFO) order.\u0026#34;) defer fmt.Println (\u0026#34;\\nThis line is being printed first because\u0026#34;) // defer se utiliza normalmente para cerrar un archivo después de abrirlo.  return true } Interfaces Como ejemplo se define una función llamada Stringer que contiene una función llamada String; luego se define una estructura de dos dígitos de tipo int nombrados x y y.\ntype Stringer interface { String() string } type pair struct { x, y int } Aquí se define la función String como un pair, convirtiéndose en un pair para la implementación de la interfaz Stringer. La variable p a continuación se llama receptor (receiver). Observar cómo se accede a los campos de estructura de pair utilizando el nombre de la estructura seguido de un punto y luego el nombre del campo.\nfunc(p pair) String() string { return fmt.Sprintf (\u0026#34;(%d, %d)\u0026#34;, p.x, p.y) } Los puntos y comas se utilizan para crear un elemento de estructura (struct). Se usa la definición corta en el siguiente ejemplo para crear una variable llamada p y especificar su tipo en la estructura de pair.\nfunc learnInterfaces() { p := pair{3, 4} // llamar función String de pair  fmt.Println(p.String()) // definir una variable como i del tipo Stringer interface previamente definida  var i Stringer // esta igualdad es correcta, porque se aplica pair de Stringer  i = p // se llama función String de la variable i de tipo Stringer y se obtiene  // el mismo resultado que antes  fmt.Println(i.String()) // al pasar las variables anteriores directamente a las funciones de impresión y salida fmt,  // estas funciones llaman a la función String para imprimir la representación de la variable. */  // Las siguientes dos líneas dan el mismo resultado de impresión  fmt.Println(p) fmt.Println(i) learnVariadicParams (\u0026#34;great\u0026#34;, \u0026#34;learning\u0026#34;, \u0026#34;here!\u0026#34;) } Múltiples entradas Es posible pasar variedad de variables a funciones sin un número definido de parámetros.\nfunc learnVariadicParams (myStrings... interface{}) { // la siguiente iteración recorre los elementos de entrada de datos de la función.  for _, param: = range myStrings { fmt.Println(\u0026#34;param:\u0026#34;, param) } // se pasa la entrada de la función variadica como parámetro de otra función (para Sprintln)  fmt.Println (\u0026#34;params:\u0026#34;, fmt.Sprintln(myStrings...)) learnErrorHandling() } Manejo de errores La palabra clave \u0026ldquo;ok\u0026rdquo; se utiliza para determinar si una sentencia es correcta. Si ocurre un error, se puede usar una variable err para conocer más detalles sobre el error.\nfunc learnErrorHandling() { m := map [int] string{3: \u0026#34;three\u0026#34;, 4: \u0026#34;four\u0026#34;} if x, ok := m[1]; !ok { // ok aquí será falso porque el número 1 no está en el mapa m  fmt.Println(\u0026#34;no one there\u0026#34;) } else { // x será el valor en el mapa  fmt.Print(x) } // aqui se intenta convertir valor de texto a número que resultará en un error,  // se imprimen los detalles del error si err no es nil */  if _, err := strconv.Atoi(\u0026#34;non-int\u0026#34;); err != nil { fmt.Println(err) } learnConcurrency() } Ejecución simultánea Usando una función anterior para hacer una suma numérica a algunos números en conjunto. Se usa make para crear una variable sin especificar un valor para ella.\nfunc learnConcurrency() { // se crea una variable de tipo canal llamada c  c := make(chan int) // creando tres funciones Go concurrentes. Los números se incrementarán simultáneamente  // (en paralelo si el dispositivo está configurado para hacerlo).  // todas las transmisiones irán al mismo canal  // \u0026#34;go\u0026#34; aquí significa iniciar una nueva función  go inc(0, c) go inc(10, c) go inc(-805, c) // luego hacer tres lecturas desde el mismo canal e imprimir los resultados.  // no hay un orden de acceso de lectura desde el canal, y  // también cuando el canal aparece a la derecha de la operación  // \u0026lt;- significa que esta leyendo y recibiendo del canal  fmt.Println(\u0026lt;-c, \u0026lt;-c, \u0026lt;-c) // nuevo canal con texto  cs := make(chan string) // canal contiene canales de texto  ccs := make(chan chan string) // enviar valor 84 al canal c  go func() {c \u0026lt;- 84}() // enviar palabra al canal cs  go func() {cs \u0026lt;- \u0026#34;wordy\u0026#34;}() // instrucción select es similar a la instrucción switch,  // pero en cada caso contiene un proceso para un canal que  // está listo para comunicarse.  select { // valor recibido del canal se puede guardar en una variable  case i := \u0026lt;-c: fmt.Printf(\u0026#34;it\u0026#39;s a %T\u0026#34;, i) case \u0026lt;-cs: fmt.Println(\u0026#34;it\u0026#39;s a string\u0026#34;) // canal vacío pero listo para comunicarse  case \u0026lt;-ccs: fmt.Println(\u0026#34;didn\u0026#39;t happen.\u0026#34;) } } "},{"href":"https://gophers-latam.github.io/opensource/","title":"Open Source","body":"Software Open Source en GitHub por Gophers LATAM.\n"},{"href":"https://gophers-latam.github.io/contacto/","title":"Contacto","body":"Medios de contacto con Gophers LATAM.\n"},{"href":"https://gophers-latam.github.io/colaboradores/","title":"Colaboradores","body":"Miembros públicos en github.com/gophers-latam\n"},{"href":"https://gophers-latam.github.io/acerca/","title":"Acerca","body":"Gophers LATAM es un esfuerzo conjunto por hacer una comunidad de programadores Golang en Español-Latino.\nLos inicios son desde el canal YouTube de Tomás Lingotti luego se adopto la idea del Discord el cual ha sido impulsado desde el mismo canal y en otros canales tal como el de Golandia y en otros medios como Facebook, Twitter y Linkedin. Como tambien desde blog de ZeroIdentidad.\nOtra forma en la que se esta adoptando hacer presencia es en Github.\n\u0026ndash; Todo lo mencionado anteriormente data desde otoño del 2020.\n"},{"href":"https://gophers-latam.github.io/proyectos/awesomelatam/","title":"Awesome Latam","body":"Colección de contenidos y recursos principalmente en Español para desarrolladores de Golang\n"},{"href":"https://gophers-latam.github.io/proyectos/gopherbot/","title":"Gopher-Bot","body":"Bot de discord como mascota y utilidad de comandos en server discord.io/go-latam.\n El bot se encuentra inactivo debido a que kintohub ya dejo de dar servicio.  "}]}