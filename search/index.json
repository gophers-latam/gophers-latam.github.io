{"results":[{"href":"https://gophers-latam.github.io/posts/2024/05/meetup-go-latam/","title":"Meetup Go LATAM","body":" Meetup Go - Latinoam√©rica üöÄ ¬°Atenci√≥n Gophers de Latinoam√©rica! üöÄ\nEstamos emocionados de anunciar la primera Meetup de Go en Latinoam√©rica, ¬°y t√∫ est√°s invitad@! üéâ\nEste evento especial, organizado por las comunidades de Gophers LATAM, Golang M√©xico y Golang Guadalajara, promete ser una experiencia inolvidable para todos los entusiastas de Go.\nEn esta Meetup √∫nica, cada comunidad tendr√° la oportunidad de presentar un orador destacado que compartir√° su experiencia y conocimientos sobre temas emocionantes relacionados con Go. Desde conceptos fundamentales hasta las √∫ltimas tendencias y mejores pr√°cticas, ¬°habr√° algo para todos los niveles de habilidad!\nOradores de la primera meetup Pero eso no es todo\u0026hellip; ¬°tambi√©n tendremos sorteos especiales para todos los asistentes! Estaremos regalando tres licencias de JetBrains. ¬°Una oportunidad imperdible para ampliar tus herramientas de desarrollo y llevar tus proyectos en Go al siguiente nivel!\n¬°No te pierdas esta oportunidad de conectarte con otros apasionados de Go, aprender de expertos de la industria y, por supuesto, divertirte! Marca tu calendario, invita a tus amigos y √∫nete a nosotros el 22 de mayo para una jornada llena de inspiraci√≥n y aprendizaje.\nY para destacar, de nuestra querida comunidad de Gophers LATAM, nos estar√°n representando:\nEl Programador Pobre, un excelente y gran miembro de la comunidad que siempre est√° presente para ayudar a los dem√°s, compartiendo su gran experiencia y habilidad a la hora de ense√±ar.\nEl Programador Pobre Y tambi√©n estar√°:\nAndr√©s Puello o mejor conocido como: if err != nil, un profesional de gran categor√≠a que se sumar√° a esta gran experiencia para la comunidad de Go en Latinoam√©rica.\nAndres Puello De las dem√°s comunidades, se presentar√°n:\nGuillermo Galv√°n Daniel Vergara üóìÔ∏è Fecha: S√°bado, 22 de mayo de 2024\nüïê Hora: 7 p.m. M√©xico | 8 p.m. Colombia | 9 p.m. Chile\nüìç Lugar: Zoom Virtual ‚û°Ô∏è bit.ly/1-go-latam\n¬°Prep√°rate para una Meetup que marcar√° historia en la comunidad de Go en Latinoam√©rica! ¬°Nos vemos all√≠! üëã\n#gomeetuplatam2024\n"},{"href":"https://gophers-latam.github.io/posts/2024/05/simplificaciones-en-creaci%C3%B3n-de-go/","title":"Simplificaciones en creaci√≥n de Go","body":" The Go Gopher https://go.dev/blog/gopher/header.jpg Para apostar todo por la expresividad del lenguaje enti√©ndase como hacer m√°s f√°cil o comprensiva la lectura y escritura, en la creaci√≥n de Go se establecieron simplificaciones fundamentales bajo la premisa \u0026ldquo;Less can be more\u0026rdquo;.\nNota: en el transcurso de los a√±os alguno que otro punto puede variar o haber derivado en otros cambios. Regular syntax (don\u0026rsquo;t need a symbol table to parse): [Sintaxis regular (no necesita una tabla de s√≠mbolos para analizar)] Se refiere a una sintaxis de lenguaje de programaci√≥n que es predecible y coherente, lo que facilita el an√°lisis del c√≥digo sin necesidad de una tabla de s√≠mbolos compleja.\nGarbage collection (only): [Recolecci√≥n de basura (solamente)] Es un proceso autom√°tico en el que el sistema de ejecuci√≥n de un lenguaje de programaci√≥n gestiona autom√°ticamente la memoria liberando objetos que ya no son necesarios.\nNo header files: [No hay archivos de encabezado] En algunos lenguajes de programaci√≥n, como C y C++, los archivos de encabezado (.h) se utilizan para declarar funciones, tipos y variables que se comparten entre varios archivos fuente (.c o .cpp). En Go, no se utilizan archivos de encabezado.\nExplicit dependencies: [Dependencias expl√≠citas] Se refiere a tener que especificar claramente las dependencias que un m√≥dulo de software tiene con otros m√≥dulos, en lugar de depender de importaciones impl√≠citas o autom√°ticas.\nNo circular dependencies: [No hay dependencias circulares] Se refiere a una restricci√≥n en la cual dos o m√°s m√≥dulos dependen uno del otro de manera circular, lo cual puede causar problemas de compilaci√≥n y dise√±o de software.\nConstants are just numbers: [Las constantes son solo n√∫meros] En Go, las constantes pueden ser cualquier tipo de valor constante, no solo n√∫meros, pero aqu√≠ se hace referencia espec√≠ficamente a que las constantes pueden ser valores num√©ricos.\nInt and int32 are distinct types: [Int y int32 son tipos distintos] En Go, int y int32 son tipos de datos distintos. Aunque int es una palabra clave para un tipo de entero de tama√±o variable en funci√≥n de la arquitectura, int32 es espec√≠ficamente un tipo de entero de 32 bits.\nLetter case sets visibility: [El caso definido de las letras establece la visibilidad] En Go, los nombres de variables, funciones y tipos que comienzan con una letra may√∫scula son visibles fuera de su paquete (exportados), mientras que los nombres que comienzan con una letra min√∫scula son privados y solo visibles dentro del paquete.\nMethods for any type (no classes): [M√©todos para cualquier tipo (no clases)] En Go, puedes definir m√©todos en cualquier tipo de datos, no solo en clases o estructuras. Esto se hace utilizando receptores.\nNo subtype inheritance (no subclasses): [No hay herencia de subtipo (no hay subclases)] En Go, no hay concepto de clases ni herencia de subclases como en lenguajes orientados a objetos tradicionales. En su lugar, se utilizan interfaces para lograr polimorfismo.\nPackage-level initialization and well-defined order of initialization: [Inicializaci√≥n a nivel de paquete y orden de inicializaci√≥n bien definido] En Go, las variables globales en un paquete pueden ser inicializadas con valores constantes o mediante funciones de inicializaci√≥n definidas en el mismo paquete. La inicializaci√≥n se realiza en un orden espec√≠fico.\nFiles compiled together in a package: [Archivos compilados juntos en un paquete] En Go, todos los archivos fuente de un paquete se compilan juntos en un solo paquete. No hay archivos de encabezado ni una separaci√≥n f√≠sica entre la declaraci√≥n y la definici√≥n de las funciones y tipos.\nPackage-level globals presented in any order: [Variables globales a nivel de paquete presentadas en cualquier orden] Las variables globales en un paquete de Go pueden ser declaradas y definidas en cualquier orden dentro del archivo fuente del paquete.\nNo arithmetic conversions (constants help): [No hay conversiones aritm√©ticas (las constantes ayudan)] En Go, las conversiones autom√°ticas entre tipos num√©ricos no se realizan impl√≠citamente, lo que ayuda a evitar errores y promueve una mayor precisi√≥n.\nInterfaces are implicit (no \u0026ldquo;implements\u0026rdquo; declaration): [Las interfaces son impl√≠citas (no hay declaraci√≥n de \u0026ldquo;implements\u0026rdquo;)] En Go, no necesitas declarar expl√≠citamente que una estructura o tipo implementa una interfaz. Si una estructura implementa todos los m√©todos de una interfaz, se considera que implementa autom√°ticamente esa interfaz.\nEmbedding (no promotion to superclass): [Incorporaci√≥n (sin promoci√≥n a superclase)] En Go, puedes embeber un tipo de estructura dentro de otro, lo que permite la composici√≥n de objetos. Sin embargo, no hay promoci√≥n autom√°tica de m√©todos como en algunos otros lenguajes orientados a objetos.\nMethods are declared as functions (no special location): [Los m√©todos se declaran como funciones (sin ubicaci√≥n especial)] En Go, los m√©todos se declaran dentro del cuerpo del paquete, junto con otras funciones.\nMethods are just functions: [Los m√©todos son solo funciones] En Go, los m√©todos son simplemente funciones que toman un receptor como su primer argumento.\nInterfaces are just methods (no data): [Las interfaces son solo m√©todos (no datos)] En Go, las interfaces se componen solo de una lista de m√©todos que los tipos que las implementan deben proporcionar.\nMethods match by name only (not by type): [Los m√©todos coinciden solo por nombre (no por tipo)] En Go, dos m√©todos diferentes en dos tipos diferentes pueden tener el mismo nombre sin conflicto, siempre y cuando se apliquen a tipos diferentes.\nNo constructors or destructors: [No hay constructores ni destructores] En Go, no hay m√©todos especiales para la inicializaci√≥n o destrucci√≥n de objetos, como en algunos lenguajes orientados a objetos. En su lugar, se utilizan funciones de inicializaci√≥n y limpieza seg√∫n sea necesario.\nPostincrement and postdecrement are statements, not expressions: [El postincremento y el postdecremento son declaraciones, no expresiones] En Go, los operadores de postincremento (i++) y postdecremento (i\u0026ndash;) se consideran declaraciones independientes y no pueden usarse como parte de expresiones m√°s grandes.\nNo preincrement or predecrement: [No hay preincremento ni predecremento] En Go, los operadores de preincremento (++i) y predecremento (\u0026ndash;i) no est√°n disponibles.\nAssignment is not an expression: [La asignaci√≥n no es una expresi√≥n] En Go, la asignaci√≥n de variables no devuelve un valor, por lo que no se puede utilizar como parte de una expresi√≥n m√°s grande. Por ejemplo, x = y no devuelve ning√∫n valor.\nEvaluation order defined in assignment, function call (no \u0026ldquo;sequence point\u0026rdquo;): [Orden de evaluaci√≥n definido en la asignaci√≥n, llamada de funci√≥n (sin \u0026ldquo;punto de secuencia\u0026rdquo;)] Se refiere al hecho de que en Go, el orden en el que se eval√∫an las expresiones dentro de una asignaci√≥n o llamada de funci√≥n est√° bien definido y no hay un \u0026ldquo;punto de secuencia\u0026rdquo; como en otros lenguajes donde el comportamiento puede ser ambiguo.\nNo pointer arithmetic: [No hay aritm√©tica de punteros] En Go, no se permite realizar operaciones aritm√©ticas directamente en punteros, como en lenguajes como C o C++.\nMemory is always zeroed: [La memoria siempre est√° inicializada a cero] En Go, la memoria asignada se inicializa siempre con cero, lo que significa que las variables y estructuras de datos se inicializan autom√°ticamente a sus valores cero por defecto.\nLegal to take address of local variable: [Legal tomar la direcci√≥n de una variable local] En Go, es perfectamente v√°lido tomar la direcci√≥n de una variable local y pasarla a funciones o devolverla como un valor, sin preocuparse por el tiempo de vida de la variable.\nNo \u0026ldquo;this\u0026rdquo; in methods: [No hay \u0026ldquo;this\u0026rdquo; en m√©todos] A diferencia de otros lenguajes orientados a objetos, en Go no hay una palabra clave \u0026ldquo;this\u0026rdquo; para referirse al receptor en los m√©todos. En su lugar, se utiliza el nombre del receptor como el primer par√°metro de los m√©todos.\nSegmented stacks: [Pilas segmentadas] Go utiliza pilas segmentadas para manejar la memoria de forma eficiente, lo que permite una mejor gesti√≥n del espacio de la pila en situaciones de concurrencia y recursi√≥n profunda.\nNo const or other type annotations: [No hay \u0026ldquo;const\u0026rdquo; u otras anotaciones de tipo] En Go, no hay una palabra clave \u0026ldquo;const\u0026rdquo; que sea como en otros lenguajes de programaci√≥n. Adem√°s, las anotaciones de tipo no son necesarias ya que el compilador puede inferir el tipo de manera autom√°tica.\nNo templates: [No hay plantillas] A diferencia de algunos lenguajes como C++ que tienen plantillas, Go no proporciona un mecanismo de plantillas para la generaci√≥n de c√≥digo gen√©rico.\nNo exceptions: [No hay excepciones] Go no utiliza excepciones como mecanismo para manejar errores excepcionales. En su lugar, se prefieren los valores de retorno de error expl√≠citos.\nBuiltin string, slice, map: [String, slice y map incorporados] En Go, los tipos string, slice y map son tipos de datos incorporados en el lenguaje y proporcionan funcionalidad para manejar cadenas, listas din√°micas y mapas respectivamente.\nArray bounds checking: [Comprobaci√≥n de l√≠mites de array] En Go, se realizan comprobaciones de l√≠mites de array en tiempo de ejecuci√≥n para asegurar que no se acceda a √≠ndices fuera del rango v√°lido del array, lo que ayuda a prevenir errores de segmentaci√≥n y otros problemas relacionados con el acceso fuera de los l√≠mites del array.\nFuente de referencia: https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html "},{"href":"https://gophers-latam.github.io/posts/2024/04/explorando-frameworks-en-go-una-gu%C3%ADa-para-principiantes/","title":"Explorando Frameworks en Go: Una Gu√≠a para Principiantes","body":" go frameworks √öltimamente, en nuestro canal de discord, hemos recibido numerosas preguntas, especialmente de aquellos que est√°n dando sus primeros pasos con Go, sobre qu√© frameworks deber√≠an considerar al comenzar a desarrollar con este lenguaje. En este post, vamos a explorar temas como la biblioteca est√°ndar, los diferentes frameworks disponibles en Go, sus opciones, cu√°les son los m√°s r√°pidos y los m√°s utilizados.\n¬øC√≥mo comenzar a escribir aplicaciones web con Go? No es imprescindible utilizar un framework para comenzar con Go; la biblioteca est√°ndar proporciona todo lo necesario para desarrollar aplicaciones de manera efectiva. Todo lo que necesitas hacer es crear una carpeta con tu archivo principal e importar el paquete net/http para comenzar a desarrollar.\nLas ventajas de utilizar la biblioteca est√°ndar en lugar de un framework son las siguientes:\nSimplicidad y Minimalismo: El paquete ‚Äúnet/http‚Äù est√° desarrollado siguiendo los principios de simplicidad y minimalismo, lo que significa que no hay una sobrecarga de funcionalidades o dependencias innecesarias, lo que puede resultar en c√≥digo m√°s limpio y f√°cil de entender.\nRendimiento: La biblioteca est√°ndar de Go est√° optimizada para un rendimiento √≥ptimo.\nFlexibilidad: El paquete ‚Äúnet/http‚Äù proporciona una gran flexibilidad para construir servidores web y manejar solicitudes HTTP de manera personalizada. Esto permite adaptar la aplicaci√≥n a requisitos espec√≠ficos sin estar limitado por las decisiones de dise√±o del framework.\nCompatibilidad: Al basarse en la biblioteca est√°ndar, las aplicaciones desarrolladas con el paquete ‚Äúnet/http‚Äù son altamente compatibles con otros paquetes y bibliotecas de Go. Esto facilita la integraci√≥n con otras partes del ecosistema de Go y reduce la posibilidad de conflictos de dependencias.\nControl Total: Al evitar el uso de frameworks, los desarrolladores tienen un control total sobre el flujo de su aplicaci√≥n. Esto significa que pueden tomar decisiones de dise√±o m√°s personalizadas y adaptar la aplicaci√≥n seg√∫n las necesidades espec√≠ficas del proyecto.\n¬øCu√°l es el mejor framework? En el mundo Go, no existe un \u0026ldquo;mejor\u0026rdquo; framework, ya que existen una variedad de ellos, cada uno con sus propias caracter√≠sticas y prop√≥sitos. La elecci√≥n del framework ideal depende en gran medida de los requisitos espec√≠ficos de tu proyecto, as√≠ como de tus preferencias personales y el estilo de desarrollo que te resulte m√°s c√≥modo.\nAlgunos frameworks populares en la comunidad de Go incluyen Chi, Fiber, Gorilla, Echo y Gin, entre otros. Cada uno de estos frameworks tiene sus puntos fuertes y d√©biles, y la mejor opci√≥n depender√° de factores como la complejidad del proyecto, la escalabilidad requerida, la facilidad de uso y la familiaridad con el framework.\nEs importante investigar y probar diferentes frameworks para determinar cu√°l se adapta mejor a nuestras necesidades y objetivos.\nSi ten√©s dudas sobre cu√°l elegir, en el siguiente repositorio de GitHub, podr√°s encontrar una lista con los frameworks de Go m√°s famosos filtrados por las estrellas obtenidas por los usuarios de dicha plataforma, tambi√©n encontraras las fechas con las √∫ltimas actualizaciones y la cantidad de forks hechos: Go Web Frameworks por Mingrammer\nY si sos un apasionado de los n√∫meros y las tablas te dejo 3 webs que te van a encantar, en las cuales se hacen los diferentes benchmarks de cada framework:\nGo Web Framework Benchmark (Actualizado en el 2020, pero en el readme nos explica como podemos ejecutar uno propio)\nGo Http Routing Benchmark (Actualizado en el 2020, pero en el readme nos explica como podemos ejecutar uno propio)\nBenchmarks (√öltima actualizaci√≥n reciba: 2023-10-17)\nLas ventajas de utilizar un framework son las siguientes:\nProductividad mejorada: Los frameworks suelen proporcionar herramientas y estructuras predefinidas que facilitan el desarrollo de aplicaciones. Esto puede reducir el tiempo necesario para construir y mantener el c√≥digo, lo que a su vez aumenta la productividad del equipo de desarrollo.\nAbstracciones √∫tiles: Los frameworks pueden ofrecer abstracciones √∫tiles que simplifican tareas comunes, como el enrutamiento, la autenticaci√≥n de usuarios, el manejo de sesiones, la validaci√≥n de datos, entre otros. Esto permite a los desarrolladores centrarse en la l√≥gica de negocio de la aplicaci√≥n en lugar de reinventar la rueda para cada proyecto.\nMejores pr√°cticas integradas: Muchos frameworks promueven el uso de mejores pr√°cticas de desarrollo, como el patr√≥n MVC (Modelo-Vista-Controlador) o la inyecci√≥n de dependencias. Esto puede resultar en un c√≥digo m√°s organizado, mantenible y escalable a medida que el proyecto crece.\nComunidad activa: Los frameworks suelen tener una comunidad activa de desarrolladores que contribuyen con bibliotecas, extensiones, tutoriales y soporte en l√≠nea. Esto puede ser √∫til para obtener ayuda, resolver problemas y mantenerse al d√≠a con las mejores pr√°cticas y las √∫ltimas actualizaciones.\nDocumentaci√≥n detallada: Los frameworks a menudo vienen con una documentaci√≥n completa y detallada que facilita el aprendizaje y el uso de las caracter√≠sticas proporcionadas. Esto puede ser especialmente √∫til para los desarrolladores que son nuevos en un lenguaje o en el desarrollo web en general.\n¬øCu√°l es la recomendaci√≥n de la comunidad? En cuanto a la recomendaci√≥n de un framework en particular por parte de la comunidad, no hay una preferencia un√°nime. Cada desarrollador tiene la libertad de elegir el framework que mejor se adapte a sus necesidades espec√≠ficas. Sin embargo, es com√∫n sugerir que la biblioteca est√°ndar de Go proporciona una base s√≥lida y completa para la mayor√≠a de los proyectos.\n"},{"href":"https://gophers-latam.github.io/posts/2024/02/codelab.-implementemos-un-worker-pool/","title":"CodeLab. Implementemos un Worker Pool","body":" Mengniu Dairy production line. Gentileza de Peter Tittenberger y flickr. https://www.flickr.com/photos/ext504/3639675762/in/photostream/ La concurrencia es una herramienta que nos ayuda a ejecutar tareas pesadas o que bloquean el avance de un proceso, mientras otras tareas se ejecutan, mejorando el rendimiento general.\nPero ¬øPodemos hacer uso de la concurrencia sin ponernos un l√≠mite?\nConcurrencia es un aspecto integral del desarrollo moderno de software que permite que nuestras aplicaciones ejecuten m√∫ltiples tareas simult√°neamente y nos permite usar efectivamente los recursos del sistema, especialmente en situaciones donde debemos llevar a cabo mucho computo u operaciones de entrada/salida.\nPero ¬øHay un L√≠mite?\nImaginemos el peri√≥do de matriculas de un colegio en donde se debe registrar el ingreso y asignar curso a cientos de alumnos. Podr√≠amos poner un funcionario encargado para el registro de cada alumno, pero solo podr√≠amos hacerlo hasta completar el m√°ximo n√∫mero de funcionarios disponibles\n¬°Adem√°s de que todas las dem√°s tareas de esos funcionarios quedar√≠an en pausa hasta terminar el proceso de registro!\nWorker pool es un patr√≥n concurrente cuya idea base es tener un n√∫mero de gorutinas esperando a que se le asignen trabajos, ejecut√°ndolos a medida que se le van asignando Como eso es poco veros√≠mil, que tal si dejamos solo a 4 funcionarios realizando el proceso de matricula mientras que los dem√°s se reparten las tareas habituales. De esta forma los 4 funcionarios registran alumnos concurrentemente. Junto con ello, esto nos permite que si vemos que se produce un cuello de botella, por ejemplo muchos apoderados llegan a registrar a sus pupilos al mismo tiempo, podemos reforzar con algunos funcionarios extra, y devolverlos a sus tareas habituales cuando se haya procesado el cuello de botella.\nPues bien, con esta analog√≠a hemos descrito el funcionamiento de un worker pool, el cual es un patr√≥n para lograr concurrencia, cuya idea base es tener un n√∫mero de gorutinas, que reciben el nombre de worker, esperando a que se le asignen trabajos. Cuando un trabajo se le asigna a un worker, se ejecuta concurrentemente mientras la gorutina principal sigue ejecutando otro c√≥digo.\nLa idea base de nuestra implementaci√≥n es gatillar bajo demanda un n√∫mero fijo de gorutinas que har√°n las veces de workers e iran recibiendo tareas a ejecutar a trav√©s de un canal por el cual las enviaremos Worker pool nos permite administrar el nivel de concurrencia de nuestras aplicaciones controlando el uso de recursos de procesamiento.\n¬°Pero basta de teor√≠a y ensuciemonos las manos que a eso hemos venido!\nImplementaremos un worker pool definiendo cada parte que lo constituye, junto con algunas utilidades para obtener m√©tricas.\nLa idea base de nuestra implementaci√≥n es gatillar bajo demanda un n√∫mero fijo de gorutinas que har√°n las veces de workers e iran recibiendo tareas a ejecutar a trav√©s de un canal por el cual las enviaremos.\nDecimos que gatillaremos bajo demanda a los workers porque los iremos levantando a medida que vayan llegando tareas y no hayan workers para ejecutarlas, hasta llegar al l√≠mite definido de workers. En pocas palabras, implementaremos una lazy inicialization de los workers de nuestro pool.\nDentro de las consideraciones de dise√±o, haremos un fuerte uso de interfaces pues nos permiten que los elementos que componen el worker pool sean plugables y posibles de reemplazar por otros componentes que implementen la interface.\nLa belleza de esto radica en que si a Ud. se le ocurre una mejor implementaci√≥n, o necesita funcionalidades extra que no est√°n contempladas, puede construir su propia implementaci√≥n de acuerdo a sus gustos o necesidades, y mientras exponga los m√©todos de la interface definida, su c√≥digo personalizado trabajar√° perfectamente con el resto del worker pool.\nTareas Dentro del contexto de programaci√≥n concurrente es usual llamar aquello que se procesa como tarea, que son trabajos que pueden ser ejecutados as√≠ncrona y concurrentemente. As√≠ que empecemos por definir la estructura de datos que nuestro worker pool ser√° capaz de procesar.\ntype Task interface { Run() } Una interface llamada Task, exponiendo un m√©todo Run que ser√° implementada por las tareas concretas que necesitemos procesar.\nExecutor y Spawner Comentamos que los workers deben levantarse a medida que las tareas vayan llegando, y que deben ir ejecutandolas. Podemos abstraer esas dos funcionalides en respectivas interfaces.\ntype Executor interface { // Execute ejecuta una tarea Task para un worker pool Pool Execute(Task, Pool) } La interface Executor tendr√° la responsabilidad de ejecutar cada tarea\ntype Spawner interface { // Spawn engendra un nuevo worker para el worker pool // recibe como argumento: // El canal por donde se recibir√°n las tareas // Una funci√≥n capaz de ejecutar una tarea // Una funci√≥n que se ejecutar√° al momento de desplegar el worker // Una funci√≥n que se ejecutar√° al momento de terminar al worker Spawn(chan Task, func(Task), func(), func()) } Spawner cuya finalidad ser√° levantar un nuevo worker cuando sea necesario.\nPool type Pool interface { // Submit Envia una nueva tarea al worker pool Submit(Task) // WaitAll Espera a que todos los workers terminen de procesar sus tareas asignadas WaitAll() // Execute Ejecuta las tareas enviadas al worker delegando en la interface [Executor] Execute(Task) // SpawnWorker Levanta un nuevo worker delegando en la interface [Spawner] SpawnWorker() // WorkerSpawned Retorna el n√∫mero de workers levantados hasta el momento WorkerSpawned() int32 // SubmittedTasks Retorna el n√∫mero de tareas enviadas a los workers SubmittedTasks() int32 // AddReadyTask agrega el deltas indicado como par√°metro a la cantidad // de tareas ejecutadas. Se usa en DefaultExecutor por ejemplo AddReadyTask(int32) // OnExecuteTask Lo usaremos como un hook para inyectar c√≥digo que se ejecutar√° cuando el [Executor] ejecute cada tarea OnExecuteTask(time.Time) // CummulatedWorkTime() time.Duration` Devuelve el tiempo de trabajo hasta el momento de su invocaci√≥n CummlatedWorkTime() time.Duration // AVGTime Devuelve el tiempo promedio de ejecuci√≥n de tareas AVGTime() time.Duration } Definimos la √∫ltima de nuestras interfaces, la interface Pool que representa al worker pool.\nCon la api de nuestro worker pool ya definida, procedemos ahora a construir una implementaci√≥n concreta.\nImplementando a Executor. DefaultExecutor type DefaultExecutor struct{} func (e *DefaultExecutor) Execute(task Task, p Pool) { start := time.Now().UTC() defer p.OnExecuteTask(start) defer p.AddReadyTask(1) task.Run() } Tal como se indic√≥ en la definici√≥n de nuestra api, el executor es responsable de gatillar la tarea recibida por el worker.\nEn esta implementaci√≥n registraremos el tiempo que las tareas demoran en ejecutarse, y para invocar al m√©todo OnExecuteTask del worker pool.\nImplementando a Spawner. DefaultSpawner. type DefaultSpawner struct{} func (s *DefaultSpawner) Spawn( tasks chan Task, executor func(Task), onStart func(), onEnd func() ) { // Antes de levantar propiamente al worker, ejecutamos la funci√≥n onStart // recibida como argumento. Esto nos da la oportunidad // de inyectar un hook al momento de levantar los workers onStart() // Levantamos al worker en su propia gorutina go func() { // registramos la funci√≥n onEnd recibidas como argumento // para que se ejecute al terminar la gorutina defer onEnd() for task := range tasks { // Dejamos un medio para terminar al worker // recibiendo una tarea con valor nil if task == nil { return } // para cada tarea recibida, invocamos a la // funci√≥n executor recibida como argumento // para que la gatille. executor(task) } }() } Implementado Pool. Deadpool Implementaremos ahora a nuestro Pool concreto, le llamaremos Deadpool por razones obvias.\nCuando definamos al constructor usaremos funciones argumentales variadicas pues nos proveen de una gran flexibilidad.\n// Definimos los posibles errores que puede gatillar la creaci√≥n de un nuevo deadpool var ( ErrInvalidMaxWorkers = errors.New(\u0026#34;invalid max number of workers\u0026#34;) ErrInvalidCap = errors.New(\u0026#34;invalid capacity for tasks stream\u0026#34;) ErrInvalidExecutor = errors.New(\u0026#34;expected a valid Executor. Nil received\u0026#34;) ErrInvalidSpawner = errors.New(\u0026#34;expected a valid Spawner. Nil received\u0026#34;) ) type deadpool struct { // maxWorkers indica la cantidad m√°xima de workers a levantar maxWorkers int32 // cap es la capacidad de tareas para el worker pool. Se usa como // el segundo par√°metro de `make` al construir el canal de tareas cap int8 // currentWorkersQTY registra la cantidad actual de workers levantados currentWorkersQTY int32 // readyTasksQTY registra la cantidad de tareas ejecutadas readyTasksQTY int32 // submittedTasksQTY registra la cantidad de tareas enviadas a los workers submittedTasksQTY int32 // registra el tiempo acumulado de proceso para las tareas ejecutadas cummulatedTime time.Duration // registra el tiempo promedio de ejecuci√≥n de las tareas avgTaskTime time.Duration // executor de tipo [Executor] es un punto de montaje para un // Executor personalizado, en caso de no proveerse uno, se usar√° //[DefaultExecutor] executor Executor // spawner de tipo [Spawner] es un punto de montaje para un // Spawner personalizado, en caso de no proveerse uno, se usar√° //[DefaultSpawner] spawner Spawner // tasksStream es el canal por donde se enviaran las tareas a los workers tasksStream chan Task wg *sync.WaitGroup mu sync.Mutex } // New devuelve un puntero a un deadpool inicializado y listo para usar. func New(opts ...func(*deadpool)) (*deadpool, error) { // Instancia de deadpool con defauklts executor y spawner d := \u0026amp;deadpool{ executor: \u0026amp;DefaultExecutor{}, spawner: \u0026amp;DefaultSpawner{}, wg: \u0026amp;sync.WaitGroup{}, mu: sync.Mutex{}, } // procesamos las funciones argumentales variadicas for _, f := range opts { f(d) } if d.maxWorkers \u0026lt;= 0 { return d, ErrInvalidMaxWorkers } if d.cap \u0026lt; 0 { return d, ErrInvalidCap } // Si por cualquier causa se pas√≥ un executor nil, terminamos con el // error correspondiente if d.executor == nil { return d, ErrInvalidExecutor } if d.spawner == nil { return d, ErrInvalidSpawner } // construimos el canal donde dejaremos caer las tareas d.tasksStream = make(chan Task, d.cap) return d, nil } func (d *deadpool) AddReadyTask(qty int32) { atomic.AddInt32(\u0026amp;d.readyTasksQTY, qty) } // Submit env√≠a una nueva tarea parea ser procesada por alg√∫n worker func (d *deadpool) Submit(task Task) { // engendramos un nuevo worker solo si es necesario d.SpawnWorker() // enviamos la tarea por el canal d.tasksStream \u0026lt;- task // aumentamos en 1 la cantidad de tareas enviadas usando una operaci√≥n at√≥mica atomic.AddInt32(\u0026amp;d.submittedTasksQTY, 1) } // WaitAll espera porque todos los workers levantados terminen sus tareas asignadas func (d *deadpool) WaitAll() { if d.tasksStream != nil { close(d.tasksStream) } d.wg.Wait() } // Execute ejecuta la tarea delegando a la implementaci√≥n de // [Executor] definida func (d *deadpool) Execute(task Task) { d.executor.Execute(task, d) } // SpawnWorker levanta un nuevo worker func (d *deadpool) SpawnWorker() { // Obtiene de una operaci√≥n at√≥mica la cantidad actual de workers levantados currentWorkersQTY := atomic.LoadInt32(\u0026amp;d.currentWorkersQTY) // si es menor a la cantidad m√°xima de workers indicada, procedemos a levantar un nuevo worker if currentWorkersQTY \u0026lt; atomic.LoadInt32(\u0026amp;d.maxWorkers) { // Para levantar un nuevo worker delegamos a la implementaci√≥n definida // de [Spawner] d.spawner.Spawn( d.tasksStream, // canal de tareas d.Execute, // funci√≥n ejecutora que al final delega al [Executer] func(workerID int32) func() { // funci√≥n a invocar al iniciar el worker return func() { // en esta implementaci√≥n lo usamos para d.wg.Add(1) // aumentar en 1 el contador de workers a esperar } }(currentWorkersQTY), func(workerID int32) func() { // funci√≥n a invocar al terminar el worker return func() { // en esta implementaci√≥n lo usamos para d.wg.Done() // disminuir en 1 el contador de workers a esperar } }(currentWorkersQTY), ) atomic.AddInt32(\u0026amp;d.currentWorkersQTY, 1) // Aumentamos en 1 la cantidad de workers levantados // con una operaci√≥n at√≥mica } } // OnExecuteTask es un hook que se provee para inyectar c√≥digo antes de ejecutar una tarea. func (d *deadpool) OnExecuteTask(start time.Time) { d.mu.Lock() defer d.mu.Unlock() // En esta implementaci√≥n lo usamos para guardar el tiempo // de ejecuci√≥n de las tareas // para calcular el cummulated execution time y el avg execution time ellapsed := time.Since(start) d.cummulatedTime += ellapsed readies := time.Duration(atomic.LoadInt32(\u0026amp;d.readyTasksQTY)) d.avgTaskTime = d.cummulatedTime / readies // Pero ud. podr√≠a usarlo para lo que quiera! } func (d *deadpool) WorkerSpawned() int32 { return d.currentWorkersQTY } func (d *deadpool) SubmittedTasks() int32 { return d.submittedTasksQTY } func (d *deadpool) AVGTime() time.Duration { return d.avgTaskTime } func (d *deadpool) CummlatedWorkTime() time.Duration { return d.cummulatedTime } /// Funciones argumentales variadicas // WithMax indica el m√°ximo n√∫mero de workers func WithMax(max int32) func(*deadpool) { return func(d *deadpool) { d.maxWorkers = max } } // WithCap indica la capacidad del canal. Si se omite el canal de tareas no estar√° buffereado func WithCap(cap int8) func(*deadpool) { return func(d *deadpool) { d.cap = cap } } // WithExecutor permite explicitar el Executor a usar. Si se omite, se usa [DefaultExecutor] func WithExecutor(exe Executor) func(*deadpool) { return func(d *deadpool) { d.executor = exe } } // WithSpawner permite explicitar el [Spawner] a usar. Si se omite, se usa [DefaultSpawner] func WithSpawner(spn WorkerSpawner) func(*deadpool) { return func(d *deadpool) { d.spawner = spn } } En nuestra implementaci√≥n hemos decidido usar el paquete atomic que provee primitivas de memoria de bajo nivel. La documentaci√≥n de Go recomienda preferir el paquete sync o canales para sincronizar memoria, pero como lo que necesitabamos hacer era aumentar en 1 algunas variables nos decantamos por atomic.\nComo ninguna implementaci√≥nm est√° terminada sin sus pruebas, construyamoslas para probar nuestro invento.\nfunc Test_deadpool_ErrsOnCreate(t *testing.T) { _, err := New(WithMax(-1)) if err == nil { t.Log(\u0026#34;ErrInvalidMaxWorkers expected\u0026#34;) t.FailNow() } _, err = New(WithCap(-1)) if err == nil { t.Log(\u0026#34;ErrInvalidCap expected\u0026#34;) t.FailNow() } _, err = New(WithExecutor(nil)) if err == nil { t.Log(\u0026#34;ErrInvalidExecutor expected\u0026#34;) t.FailNow() } _, err = New(WithSpawner(nil)) if err == nil { t.Log(\u0026#34;ErrInvalidSpawner expected\u0026#34;) t.FailNow() } } El test anterior comprueba que los posibles errores al instanciar a nuestro pool se gatillen correctamente.\nAhora implementemos un mock de una tarea para poder probar la infraestructura completa.\ntype taskTest struct { id int } func newTaskTest(id int) *taskTest { return \u0026amp;taskTest{ id: id, } } func (t *taskTest) Run() { defer func() { if os.Getenv(\u0026#34;DEBUG\u0026#34;) == \u0026#34;TRUE\u0026#34; { fmt.Printf(\u0026#34; stoping task %d\\n\u0026#34;, t.id) } }() if os.Getenv(\u0026#34;DEBUG\u0026#34;) == \u0026#34;TRUE\u0026#34; { fmt.Printf(\u0026#34; starting task %d\\n\u0026#34;, t.id) time.Sleep(10 * time.Millisecond) } } Simulamos un trabajo en nuestra implementaci√≥n mock de tarea esperando durante 10 milisegundos. Adem√°s, agregamos unas comprobaciones a la variable de entorno DEBUG para poder ver logs del inicio y fin de la ejecuci√≥n de las tareas mock.\nfunc Test_deadpool_Flow(t *testing.T) { // Instanciamos un nuevo deadpool con un m√°ximo de 6 workers d, err := New(WithMax(6)) if err != nil { t.Log(err) t.FailNow() } start := time.Now().UTC() // Enviaremos al worker pool 128 de nuestras tareas mock for i := 1; i \u0026lt;= 128; i++ { func(i int) { d.Submit(newTaskTest(i)) }(i) } d.WaitAll() // estadisticas t.Logf(\u0026#34;tiempo acumulado de proceso: %v\\n\u0026#34;, d.CummlatedWorkTime()) t.Logf(\u0026#34;tiempo promedio por tarea: %v \\n\u0026#34;, d.AVGTime()) t.Logf(\u0026#34;tiempo total de proceso: %v\u0026#34;, time.Since(start)) } Y al ejecutar nuestro test con la variable de entrono DEBUG con valor TRUE podemos ver el resultado.\n$ DEBUG=TRUE go test -timeout 256s -run ^Test_deadpool_Flow$ github.com/profe-ajedrez/deadpool -v === RUN Test_deadpool_Flow starting task 1 starting task 2 starting task 3 starting task 4 ... stoping task 122 stoping task 125 stoping task 128 stoping task 127 deadpool_test.go:60: tiempo acumulado de proceso: 1.298687182s deadpool_test.go:61: tiempo promedio por tarea: 10.145993ms deadpool_test.go:62: tiempo total de proceso: 223.349239ms --- PASS: Test_deadpool_Flow (0.22s) Donde vemos que el tiempo sumado de la ejecuci√≥n de todas las tareas fue 1.298687182s, pero el tiempo total de proceso solo fue de 223.349239ms, mientras que cada tarea demoro en promedio 10.145993ms que es una fracci√≥n mayor a los 10ms que le indicamos que deb√≠a esperar la tarea mock.\nComo alternativa al worker pool, seg√∫n sea nuestro caso podriamos haber implementado un pipeline, que consiste en una cadena de gorutinas cada una de las cuales realiza una acci√≥n sobre un elemento hasta completarlo, y cuya analog√≠a es una l√≠nea de producci√≥n.\nSea cual sea el patr√≥n concurrente que elijamos, debemos ser cuidadosos de no provocar condiciones de carrera ni fugas de gorutinas, por lo que debemos hacer uso exhaustivo del flag -race al ejecutar nuestras pruebas.\nHemos implementado un worker pool funcional, pero aun no hemos respondido a la pregunta con que iniciamos este art√≠culo ¬øHay alg√∫n l√≠mite para la concurrencia? Preferimos dejar la pregunta abierta y esperamos sus respuestas en los comentarios.\nPuede hackear el c√≥digo que hemos construido en este playground, y como de costumbre, le proveemos con el repositorio donde se aloja.\nY bien, con eso llegamos al final de este codelab. Esperamos que haya sido de su agrado y como siempre le recordamos que si le gust√≥ este art√≠culo no dude en compartirlo o en comentarnos si considera que hay algo en lo que podamos mejorar.\n"},{"href":"https://gophers-latam.github.io/posts/2024/01/concatenando-strings.-construyendo-sql/","title":"Concatenando strings. Construyendo SQL","body":" json to go Los strings son un tipo de dato peculiar. A simple vista parecieran no esconder nada raro, pero si los comparamos con tipos de dato num√©ricos encontramos diferencias interesantes.\nUn string compuesto de solo un caracter, por ejemplo \u0026ldquo;A\u0026rdquo;, ocupa un byte completo para almacenarse. En un byte el n√∫mero entero sin signo mas peque√±o que podemos guardar es 0, siendo 255 el mas grande posible de almacenarse. O sea, un solo caracter como \u0026ldquo;A\u0026rdquo; ocupa la misma cantidad de memoria que un valor del tipo uint8.\nEntonces ¬øCuanta memoria podemos usar al concatenar una enorme cantidad de caracteres en strings de gran tama√±o? Investigu√©moslo con uno de los usos mas frecuentes de construcci√≥n din√°mica de strings; la creaci√≥n de consultas SQL.\nTerminaremos adem√°s con una bonita t√©cnica para disminuir aun mas los direccionamientos al guardar los par√°metros para la consulta SQL en un slice.\nNosotros no le creemos nada a nadie, todo lo comprobamos por nosotros mismos. Por eso acompa√±amos cada ejemplo con su respectivo benchmark. ¬°Ud. deber√≠a hacer lo mismo ya que proveemos los benchmarks para este experimento! Construiremos una consulta sql de varias formas distintas y mediremos su eficiencia con benchmarks.\nUsaremos el siguiente struct para proveer los datos para construir el filtro:\ntype Filter struct { ID int64 // provee el id a buscar Name string // provee el nombre a buscar Lastname string Search string // provee un valor por cual buscar usando LIKE a nombres o apellidos Limit int64 Offset int64 } Usaremos la siguiente constante como base para la consulta que construiremos:\nconst qb = `SELECT id, name, last_name FROM clientes WHERE 1=1 %ATTRS% %ID% %FIRST_NAME% %LAST_NAME% %LIMIT% %OFFSET%` Y la funci√≥n que construye la consulta con dicho filtro, la cual se basa en la t√©cnica de colocar patrones en el texto y reemplazarlos al ir construyendo la consulta concatenando strings sucesivos:\nfunc QueryBuilderEvil(f Filter) (string, []any) { sql := qb var params []any if strings.TrimSpace(f.Search) != \u0026#34;\u0026#34; { sql = strings.ReplaceAll(sql, \u0026#34;%ATTRS%\u0026#34;, \u0026#34; AND ( name LIKE ? OR last_name LIKE ?)\u0026#34;) params = append(params, \u0026#34;%\u0026#34;+f.Search+\u0026#34;%\u0026#34;, \u0026#34;%\u0026#34;+f.Search+\u0026#34;%\u0026#34;) } else { sql = strings.ReplaceAll(sql, \u0026#34;%ATTRS%\u0026#34;, \u0026#34;\u0026#34;) } if f.ID \u0026gt; 0 { sql = strings.ReplaceAll(sql, \u0026#34;%ID%\u0026#34;, \u0026#34; AND id = ?\u0026#34;) params = append(params, f.ID) } else { sql = strings.ReplaceAll(sql, \u0026#34;%ID%\u0026#34;, \u0026#34;\u0026#34;) } if strings.TrimSpace(f.Name) != \u0026#34;\u0026#34; { sql = strings.ReplaceAll(sql, \u0026#34;%FIRST_NAME%\u0026#34;, \u0026#34; AND name = ?\u0026#34;) params = append(params, f.Name) } else { sql = strings.ReplaceAll(sql, \u0026#34;%FIRST_NAME%\u0026#34;, \u0026#34;\u0026#34;) } if strings.TrimSpace(f.Lastname) != \u0026#34;\u0026#34; { sql = strings.ReplaceAll(sql, \u0026#34;%LAST_NAME%\u0026#34;, \u0026#34; AND last_name = ?\u0026#34;) params = append(params, f.Lastname) } else { sql = strings.ReplaceAll(sql, \u0026#34;%LAST_NAME%\u0026#34;, \u0026#34;\u0026#34;) } if f.Limit \u0026gt; 0 { sql = strings.ReplaceAll(sql, \u0026#34;%LIMIT%\u0026#34;, \u0026#34; LIMIT ?\u0026#34;) params = append(params, f.Limit) } else { sql = strings.ReplaceAll(sql, \u0026#34;%LIMIT%\u0026#34;, \u0026#34;\u0026#34;) } if f.Offset \u0026gt; 0 { sql = strings.ReplaceAll(sql, \u0026#34;%OFFSET%\u0026#34;, \u0026#34; OFFSET ?\u0026#34;) params = append(params, f.Offset) } else { sql = strings.ReplaceAll(sql, \u0026#34;%OFFSET%\u0026#34;, \u0026#34;\u0026#34;) } return sql, params } Antes de analizar, veamos el resultado del benchmark de esta funci√≥n. En mi m√°quina arroja estos resultados:\nfunc BenchmarkEvil(b *testing.B) { f := Filter{ Name: \u0026#34;a\u0026#34;, Lastname: \u0026#34;b\u0026#34;, Search: \u0026#34;\u0026#34;, Limit: 10, } b.ResetTimer() for i := 0; i \u0026lt;= b.N; i++ { _, _ = QueryBuilderEvil(f) } } BenchmarkEvil-16 1655064\t705.8 ns/op\t720 B/op\t11 allocs/op El benchmark nos dice que se ejecut√≥ la funci√≥n 18720764 veces, durando 764 ns cada iteraci√≥n, direccionado 784 bytes cada iteraci√≥n, realizando 11 localizaciones al heap.\n¬øParece r√°pido? ¬øQue puede tener esto de malo? Observe los bytes direccionados, 784. Esto, mas o menos significa que se guardaron en memoria el equivalente a 784 letras \u0026ldquo;A\u0026rdquo;.\nReunamos mas informaci√≥n. Usemos el flag -gcflags=\u0026quot;-m\u0026quot; para descubrir donde se producen los direccionamientos en el heap.\n./main_test.go:21:15: q escapes to heap ./main.go:89:39: \u0026#34;%\u0026#34; + f.Search + \u0026#34;%\u0026#34; escapes to heap ./main.go:89:39: \u0026#34;%\u0026#34; + f.Search + \u0026#34;%\u0026#34; escapes to heap ./main.go:89:57: \u0026#34;%\u0026#34; + f.Search + \u0026#34;%\u0026#34; escapes to heap ./main.go:89:57: \u0026#34;%\u0026#34; + f.Search + \u0026#34;%\u0026#34; escapes to heap ¬°Observe adem√°s que cada concatenaci√≥n con + escapa al heap! Cada una genera un direccionamiento nuevo, Lo que si ley√≥ un art√≠culo anterior, entender√° que puede ser susceptible de mejorar.\nPero ¬øQue alternativas hay?\nConstruyendo strings de forma eficiente con strings.Builder Tratemos de mejorar nuestra implementaci√≥n. Usando el mismo struct para el filtro, cambiemos la constante base de sql.\nconst q = `SELECT id, name, last_name FROM clientes WHERE 1=1` Y revisemos esta funci√≥n alternativa para construir la consulta:\nb := strings.Builder{} // le indicamos una capacidad al slice que contendr√° los par√°metros de la query // iguala la cantidad m√°xima de elementos posibles de agregar al filtro params := make([]any, 0, 7) b.WriteString(q) if f.ID \u0026gt; 0 { b.WriteString(\u0026#34; AND id = ?\u0026#34;) // Agregamos el segmento del filtro sql y el par√°metro posicional params = append(params, f.ID) } if strings.TrimSpace(f.Name) != \u0026#34;\u0026#34; { // N√≥tese el espacio extra antes del sql b.WriteString(\u0026#34; AND name = ?\u0026#34;) params = append(params, f.Name) } if strings.TrimSpace(f.Lastname) != \u0026#34;\u0026#34; { b.WriteString(\u0026#34; AND last_name = ?\u0026#34;) params = append(params, f.Lastname) } if strings.TrimSpace(f.Search) != \u0026#34;\u0026#34; { b.WriteString(\u0026#34; AND ( name LIKE ? OR last_name LIKE ?)\u0026#34;) params = append(params, fmt.Sprintf(\u0026#34;%%%s%%\u0026#34;,f.Search), fmt.Sprintf(\u0026#34;%%%s%%\u0026#34;,f.Search)) } if f.Limit \u0026gt; 0 { b.WriteString(\u0026#34; LIMIT ?\u0026#34;) params = append(params, f.Limit) } if f.Offset \u0026gt; 0 { b.WriteString(\u0026#34; OFFSET ?\u0026#34;) params = append(params, f.Offset) } return b, params Revisemos el resultado del benchmark:\nfunc BenchmarkOK(b *testing.B) { f := Filter{ Name: \u0026#34;a\u0026#34;, Lastname: \u0026#34;b\u0026#34;, Search: \u0026#34;\u0026#34;, Limit: 10, } b.ResetTimer() for i := 0; i \u0026lt;= b.N; i++ { _, _ = QueryBuilderOK(f) } } BenchmarkOK-16 6253722\t234.3 ns/op\t336 B/op\t5 allocs/op ¬°Vaya! hemos pasado de 705.8 ns a 234.3 ns, y de un consumo de memoria de 720 bytes disminuimos a 336 bytes ¬°Bastante bien no!\nGracias al uso eficiente de strings.Builder podemos evitar concatenaciones costosas. Estas mejoras se explican porque este nuevo constructor de la consulta delega el manejo de la construcci√≥n del string a strings.Builder, cuya documentaci√≥n nos explica que es un tipo de dato que permite construir strings minimizando las copias de memoria que como Ud. ya est√° imaginando es donde se produce la demora en ejecuci√≥n y el costo.\nGracias al uso eficiente de strings.Builder podemos dejar de usar la t√©cnica de b√∫squeda y reemplazo en el string que estamos construyendo y podemos evitar concatenaciones costosas.\nLlevando esto al extremo ¬øHasta que punto deber√≠amos llegar al pensar en evitar concatenaciones y reemplazarlas por strings.Builder?\nDepende de lo que estemos tratando de hacer. Por ejemplo, en nuestra funci√≥n QueryBuilderOK Ud. podr√≠a decir que en donde se construyen los likes se esta usando fmt.Sprintf, y si acaso no ser√≠a mejor usar un builder.\n¬°Comprobemoslo! Construyamos una tercera funci√≥n para generar nuestra consulta sql.\nfunc QueryBuilderOKAlter(f Filter) (strings.Builder, []any) { b := strings.Builder{} params := make([]any, 0, 7) // 7 es la cantidad m√°xima de elementos que se pueden agregar al filtro b.WriteString(q) if f.ID \u0026gt; 0 { b.WriteString(\u0026#34; AND id = ?\u0026#34;) // Agregamos el segmento del filtro sql y el par√°metro posicional params = append(params, f.ID) } if strings.TrimSpace(f.Name) != \u0026#34;\u0026#34; { // N√≥tese el espacio extra antes del sql b.WriteString(\u0026#34; AND name = ?\u0026#34;) params = append(params, f.Name) } if strings.TrimSpace(f.Lastname) != \u0026#34;\u0026#34; { b.WriteString(\u0026#34; AND last_name = ?\u0026#34;) params = append(params, f.Lastname) } if strings.TrimSpace(f.Search) != \u0026#34;\u0026#34; { b.WriteString(\u0026#34; AND ( name LIKE ? OR last_name LIKE ?)\u0026#34;) b2 := strings.Builder{} b2.WriteString(\u0026#34;%\u0026#34;) b2.WriteString(f.Search) b2.WriteString(\u0026#34;%\u0026#34;) params = append(params, b2.String()) b2.Reset() b2.WriteString(\u0026#34;%\u0026#34;) b2.WriteString(f.Search) b2.WriteString(\u0026#34;%\u0026#34;) params = append(params, b2.String()) } if f.Limit \u0026gt; 0 { b.WriteString(\u0026#34; LIMIT ?\u0026#34;) params = append(params, f.Limit) } if f.Offset \u0026gt; 0 { b.WriteString(\u0026#34; OFFSET ?\u0026#34;) params = append(params, f.Offset) } return b, params } Con su benchmark respectivo\nfunc BenchmarkOKAlter(b *testing.B) { f := Filter{ Name: \u0026#34;a\u0026#34;, Lastname: \u0026#34;b\u0026#34;, Search: \u0026#34;\u0026#34;, Limit: 10, } b.ResetTimer() for i := 0; i \u0026lt;= b.N; i++ { _, _ = QueryBuilderOKAlter(f) } } Y ejecutemos varias veces los benchmarks para considerar peque√±as variaciones.\n# Usamos el flag -count para indicar el n√∫mero de ejecuciones # de nuestros benchmarks # y el flag -benchtime para indicar el tiempo m√≠nimo que deber√≠a durar cada bench go test -benchmem -count=16 -benchtime=2s -bench . goos: linux goarch: amd64 pkg: aa cpu: Intel(R) Core(TM) i7-10700 CPU @ 2.90GHz BenchmarkEvil-16 3066897 744.7 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3498865 727.4 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3386638 718.1 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3180061 728.8 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3392404 741.4 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3488655 732.3 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3306530 736.1 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3028632 718.3 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3517440 710.5 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3404026 704.9 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3467962 756.4 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3440934 738.0 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3392062 711.4 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3522846 735.8 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3203848 701.6 ns/op 720 B/op 11 allocs/op BenchmarkEvil-16 3502076 732.7 ns/op 720 B/op 11 allocs/op BenchmarkOK-16 11799339 228.8 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 11871458 228.2 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 11488488 264.0 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 12074823 236.2 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 9447732 229.9 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 10044681 204.5 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 12510486 232.0 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 10445984 256.5 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 11243646 250.3 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 11259970 251.3 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 9696850 247.5 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 11768199 285.7 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 10200710 235.4 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 9136749 232.4 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 9717814 242.0 ns/op 336 B/op 5 allocs/op BenchmarkOK-16 10739455 240.3 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 10271550 246.1 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 8569068 237.5 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 8484096 277.7 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 8993108 265.8 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 8013882 286.9 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 8815909 240.2 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 9611652 261.0 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 8601260 234.4 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 9384111 256.7 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 7744686 268.7 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 8082067 289.4 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 11854416 213.5 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 10229622 286.3 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 10405981 219.1 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 8921347 242.1 ns/op 336 B/op 5 allocs/op BenchmarkOKAlter-16 11861126 261.1 ns/op 336 B/op 5 allocs/op PASS ok aa 144.342s Si tomamos los resultados y los ordenamos desde el m√°s r√°pido hasta el mas lento, vemos que no hay una gran diferencia entre las funciones OK, y que incluso QueryBuilderOK es un poco mas veloz que QueryBuilderOKAlter.\nEn el apartado de memoria ambas gastaron la misma cantidad y realizaron el mismo n√∫mero de direccionamientos.\n¬øEsto significa que cuando necesitemos hacer pocas concatenaciones, o cuando lo tengamos que hacer sobre strings muy peque√±os no deber√≠amos usar strings.Builder?\n¬°No lo se! Depender√° de que tan pocas concatenaciones y que tan peque√±os sean los strings de su caso. Lo √∫nico que puedo recomendarle es construir su programa de forma tal que pueda realizar los benchmarks correspondientes y tomar la decisi√≥n con base a los n√∫meros presentados por estos en cada situaci√≥n.\nAplicando la t√©cnica de m√°scaras de par√°metros Ahora bien, En el caso de nuestro ejemplo hay formas de optimizar aun mas a nuestro builder que ya no pasan directamente por el manejo del string. Podemos usar la t√©cnica de usar una m√°scara para determinar el tama√±o exacto de los par√°metros a agregar a la consulta y direccionar previamente la memoria con ese n√∫mero para evitar realizar appends mientras se va construyendo la consulta, de la misma forma que evitamos concatenar gracias a strings.Builder.\nfunc QueryBuilderOKMask(f Filter) (strings.Builder, []any) { b := strings.Builder{} // tenemos una instancia de un struct con un campo booleano para // cada elemento del filtro mask := struct { ID bool Name bool Lastname bool Search bool Limit bool Offset bool }{} b.WriteString(q) // Usaremos a size para indicar cuantos elementos tendr√° finalmente el slice de par√°metros de la consulta size := 0 if f.ID \u0026gt; 0 { b.WriteString(\u0026#34; AND id = ?\u0026#34;) // Agregamos el segmento del filtro sql y el par√°metro posicional // Si el elemento del filtro se agrega, se establece su m√°scara a verdadero mask.ID = true // y se aumenta en 1 el tama√±o esperado para el slice de par√°metros size++ } if strings.TrimSpace(f.Name) != \u0026#34;\u0026#34; { b.WriteString(\u0026#34; AND name = ?\u0026#34;) mask.Name = true size++ } if strings.TrimSpace(f.Lastname) != \u0026#34;\u0026#34; { b.WriteString(\u0026#34; AND last_name = ?\u0026#34;) mask.Lastname = true size++ } if strings.TrimSpace(f.Search) != \u0026#34;\u0026#34; { b.WriteString(\u0026#34; AND ( name LIKE ? OR last_name LIKE ?)\u0026#34;) mask.Search = true size += 2 } if f.Limit \u0026gt; 0 { b.WriteString(\u0026#34; LIMIT ?\u0026#34;) mask.Limit = true size++ } if f.Offset \u0026gt; 0 { b.WriteString(\u0026#34; OFFSET ?\u0026#34;) mask.Offset = true size++ } // direccionamos el slice de par√°metros con la memoria exacta que necesitamos p := make([]any, size) i := 0 // y solo agregamos al slice los elementos del filtro que tengan su respectiva m√°scara activada if mask.ID { p[i] = f.ID i++ } if mask.Name { p[i] = f.Name i++ } if mask.Lastname { p[i] = f.Lastname i++ } if mask.Search { p[i] = fmt.Sprintf(\u0026#34;%%%s%%\u0026#34;, f.Search) i++ p[i] = fmt.Sprintf(\u0026#34;%%%s%%\u0026#34;, f.Search) i++ } if mask.Limit { p[i] = f.Limit i++ } if mask.Offset { p[i] = f.Offset } return b, p } El respectivo benchmark\nfunc BenchmarkOKMask(b *testing.B) { f := Filter{ Name: \u0026#34;a\u0026#34;, Lastname: \u0026#34;b\u0026#34;, Search: \u0026#34;\u0026#34;, Limit: 10, } b.ResetTimer() for i := 0; i \u0026lt;= b.N; i++ { _, _ = QueryBuilderOKMask(f) } } El cual al ejecutarse nos arroja los siguientes resultados.\nBenchmarkOKMask-16 10261683 213.8 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 12145034 230.7 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 9883455 213.3 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 10661880 212.3 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 12725306 211.5 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 9966832 225.5 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 9271009 216.3 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 8934564 236.4 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 12176293 249.7 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 11495956 236.9 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 10586841 224.2 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 12398922 213.3 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 9481837 247.0 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 10852344 226.4 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 12089485 216.7 ns/op 272 B/op 5 allocs/op BenchmarkOKMask-16 10944657 201.9 ns/op 272 B/op 5 allocs/op !Vemos una mejora en el consumo de memoria y en la velocidad de ejecuci√≥n!\nConcluyendo, no le crea a nada ni a nadie, compruebelo todo con benchmarks por si mismo en un ambiente lo mas parecido a sus m√°quinas de producci√≥n si le es posible. Detecte los cuellos de botella en su programa y aplique las medidas que su experiencia y conocimiento provean.\nDejamos a su disposici√≥n el c√≥digo provisto en este art√≠culo en este repositorio.\nY con esto despedimos este art√≠culo, no olvide comentar si precisa hacer alg√∫n alcance y compartirlo si es que le gust√≥.\n"},{"href":"https://gophers-latam.github.io/posts/2024/01/desarrollo-con-go-en-neovim/","title":"Desarrollo con Go en Neovim","body":" Go con Neovim En este post vamos a ver c√≥mo configurar desde cero Neovim y espec√≠ficamente c√≥mo personalizarlo para que nuestro desarrollo con Go sea altamente productivo.\nInstalaci√≥n Lo primero que debemos de hacer es instalar Neovim.\nSi estamos en Windows, lo podemos hacer de la siguiente manera:\nwinget install Neovim.Neovim o tambi√©n se puede realizar mediante gestores de paquetes externos como: Chocolatey o Scoop:\n# scoop scoop bucket add main scoop install neovim # chocolatey choco install neovim # (Podes usar `-y` para saltear automaticamente la confirmacion de mensajes). Y si est√°s en Linux, lo pod√©s hacer de la siguiente manera, dependiendo de tu gestor de paquetes:\n# Arch sudo pacman -S neovim # Debian sudo apt-get install neovim # Fedora sudo dnf install -y neovim python3-neovim Para las dem√°s distribuciones de Linux o para instalarlo de manera local, les dejo la documentaci√≥n correspondiente.\nTener en cuenta que, dependiendo la distribuci√≥n que se elija, ser√° diferente la versi√≥n. Es decir, si descargamos Neovim en Ubuntu, vendr√° con la versi√≥n 0.6 mientras que si se descarga en Manjaro, vendr√°n con la √∫ltima versi√≥n estable (esto por la gesti√≥n de paquetes de cada distro).\nEs por esto que es siempre mejor descargar la √∫ltima versi√≥n estable desde el c√≥digo fuente, ya que nos aseguramos que nuestra versi√≥n sea la √∫ltima y compatible con las √∫ltimas novedades de Neovim.\nGesti√≥n de carpetas Una vez instalado Neovim, vamos a generar nuestras carpetas.\nEn Linux, haremos lo siguiente en: ~/.config/nvim. Si nuestra carpeta no existe, la creamos.\nEn Windows, sera en: Local Disk (C:)/Users/tu-usuario/AppData/Local/nvim. Si nuestra carpeta no existe, la creamos.\nnvim/ ‚îú‚îÄ‚îÄ after/ ‚îÇ ‚îî‚îÄ‚îÄ plugin/ ‚îÇ ‚îú‚îÄ‚îÄ tokyonight.lua ‚îÇ ‚îî‚îÄ‚îÄ telescope.lua ‚îú‚îÄ‚îÄ lua/ ‚îÇ ‚îî‚îÄ‚îÄ tu-nombre/ ‚îÇ ‚îú‚îÄ‚îÄ init.lua ‚îÇ ‚îú‚îÄ‚îÄ packer.lua ‚îÇ ‚îú‚îÄ‚îÄ remap.lua ‚îÇ ‚îî‚îÄ‚îÄ set.lua ‚îú‚îÄ‚îÄ plugin/ ‚îÇ ‚îî‚îÄ‚îÄ packer_compiled.lua ‚îî‚îÄ‚îÄ init.lua A continuaci√≥n se explica para qu√© sirve cada carpeta.\nafter/plugin: Dentro de esta, creamos los .lua con el nombre del plugin que descarguemos para configurar como queramos nuestros plugins. En el arbol de referencia se ve los archivos tokyonight.lua y telescope.lua que nos sirven como ejemplo (no hace falta crear estos .lua, mas adelante se muestran ejemplos para su comprensi√≥n).\nlua/tu-nombre: Aqu√≠, cambiaremos {tu-nombre} por tu nombre, en mi caso thiago, y dentro tendremos los archivos que nos servir√°n para descargar y setear nuestros atajos y configuraciones de Nvim.\nplugin: Esta carpeta no debemos generarla, contiene un archivo (packer_compiled.lua) que tambi√©n se genera autom√°ticamente como la carpeta /plugin/. En el archivo, ira toda nuestra configuraci√≥n de Neovim. Es importante saber que no debemos tocar este archivo. Como informaci√≥n adicional, esta carpeta se generar√° una vez que ejecutamos el comando :PackerSync m√°s adelante.\ninit.lua: En este archivo, haremos el llamado de la carpeta \u0026ldquo;tu-nombre\u0026rdquo;, para que al iniciar se carguen autom√°ticamente nuestras configuraciones.\nSi bien entraremos en detalle m√°s adelante de cada archivo y configuraci√≥n, est√° bueno saber el set up de nuestro editor de texto.\nPacker (Gestor de plugins) Ya con nuestras carpetas generadas, vamos a instalar Packer que ser√° nuestro gestor de plugins para Neovim.\nEs cierto que este repositorio no se mantiene desde Agosto de 2023, y que muchos usuarios de Neovim est√°n migrando a Lazy o Pckr (el sucesor de packer), pero para este post usaremos Packer, ya que sentar√° las bases de nuestro conocimiento para Neovim y luego podremos realizar otro post sobre la migraci√≥n a Lazy (esto debido a que quien escribe, actualmente, no migr√≥ su gestor a otro üòÖ).\nPara instalar packer, debemos de hacerlo de la siguiente manera:\nInstalaci√≥n en Unix, Linux.\ngit clone --depth 1 https://github.com/wbthomason/packer.nvim\\ ~/.local/share/nvim/site/pack/packer/start/packer.nvim Instalaci√≥n en Windows PowerShell.\ngit clone https://github.com/wbthomason/packer.nvim \u0026#34;$env:LOCALAPPDATA\\nvim-data\\site\\pack\\packer\\start\\packer.nvim\u0026#34; Una vez instalado, iremos al siguiente path: .config/nvim/lua/tu-nombre/ e ingresaremos al archivo packer.lua en donde ingresaremos el siguiente c√≥digo:\nreturn require(\u0026#39;packer\u0026#39;).startup(function(use) use \u0026#39;wbthomason/packer.nvim\u0026#39; end) Una vez hecho los cambios, haremos el siguiente comando en el modo normal: :so y enter. Y luego de esto haremos: :PackerSync para instalar el nuevo paquete que agregamos (tambi√©n se generar√° la carpeta /plugin/ y su respectivo archivo)\nY ya que estamos realizando modificaciones, iremos a nvim/lua/tu-nombre/ y agregaremos los siguientes cambios en:\nnvim/lua/tu-nombre/init.lua require(\u0026#34;tu-nombre.set\u0026#34;) require(\u0026#34;tu-nombre.remap\u0026#34;) y en nuestro init.lua de nvim/init.lua: require(\u0026#34;tu-nombre\u0026#34;) Personalizaci√≥n ya con nuestra configuraci√≥n b√°sica, vamos a poner bonito nuestro editor de texto, ya que por default viene vac√≠o.\nEn: lua/tu-nombre/set.lua, vamos a setear lo b√°sico de nuestro editor de texto:\nvim.opt.nu = true -- Muestra el n√∫mero de l√≠nea actual. vim.opt.smartindent = true -- Habilita el autoindentado inteligente. vim.opt.cursorline = true -- Resalta la l√≠nea en la que se encuentra el cursor. vim.opt.clipboard:append(\u0026#34;unnamedplus\u0026#34;) -- Configura el portapapeles para usar el registro \u0026#34;unnamedplus\u0026#34; (clipboard). vim.opt.termguicolors = true -- Habilita los colores de la terminal si es posible. vim.opt.tabstop = 4 vim.opt.softtabstop = 4 vim.opt.shiftwidth = 4 vim.opt.expandtab = true Y en lua/tu-nombre/remap.lua, vamos a realizar nuestros mapeos.\nPara ejecutar un plugin que instalamos se hace de la siguiente manera: :Plugin-a-Ejecutar\nPero esto es tedioso, por lo que en este archivo .lua, podemos configurarlo para que con ciertas combinaciones se ejecute el plugin que queramos.\nlocal keymap = vim.keymap -- Creamos esta variable para no estar constantemente escribiendo vim.keymap.set({}) local opts = { noremap = true, silent = true } -- Esto se hace para que nuestro atajo sea silencioso y no afecte tu vista. vim.g.mapleader = \u0026#34; \u0026#34; -- Seteamos la tecla espacio como lider. Esto nos servira mas adelante para mapear nuestros atajos. -- Usaremos este mapeo como ejemplo keymap.set(\u0026#34;n\u0026#34;, \u0026#34;\u0026lt;leader\u0026gt;q\u0026#34;, \u0026#34;:q\u0026lt;CR\u0026gt;\u0026#34;) -- Como bien sabemos, para salir de Nvim, se hace con :q. Entonces este mapeo, lo que nos permite es salir de nvim utilizando la combinacion de teclas: \u0026lt;leader\u0026gt; + q. -- \u0026lt;leader\u0026gt; lo seteamos mas arriba (vim.g.mapleader = \u0026#34; \u0026#34;), puede ser cualquier tecla y \u0026lt;CR\u0026gt; es un enter. -- Es lo mismo que hacer :q + enter, nada mas que lo asignamos a un mapeo y ejecutaremos esta funcion de forma facil y rapida. -- Ahora salir de Nvim no sera un problema. Para poder trabajar con temas de colores, lo haremos de la siguiente manera en: nvim/lua/tu-nombre/packer.lua\nreturn require(\u0026#39;packer\u0026#39;).startup(function(use) use \u0026#39;wbthomason/packer.nvim\u0026#39; -- Gestor de paquetes. use \u0026#39;folke/tokyonight.nvim\u0026#39; -- Esquema de colores. use(\u0026#34;nvim-treesitter/nvim-treesitter\u0026#34;, { run = \u0026#34;:TSUpdate\u0026#34; }) -- Nos provee un resaltado de colores en nuestro codigo. use({ \u0026#34;nvim-lualine/lualine.nvim\u0026#34;, -- Barra de estado. requires = { \u0026#34;kyazdani42/nvim-web-devicons\u0026#34;, opt = true }, }) use({ \u0026#34;nvim-tree/nvim-tree.lua\u0026#34;, -- Arbol de archivos. requires = { \u0026#34;nvim-tree/nvim-web-devicons\u0026#34;, }, }) use(\u0026#34;fatih/vim-go\u0026#34;) -- Para el desarrollo con Go. end) Una vez que tengamos los plugins que necesitemos, haremos lo que hicimos en pasos previos\n:so y enter y luego :PackerSync para poder instarlos.\nUna vez instalados, debemos de ir a nvim/after/plugin/ y crear los archivos .lua para cada plugin que descargamos. Por ejemplo.\nnvim/after/plugin/lualine.nvim require(\u0026#39;lualine\u0026#39;).setup({ options = { theme = \u0026#34;auto\u0026#34; } }) nvim/after/plugin/nvim-treesitter.lua require(\u0026#39;nvim-treesitter.configs\u0026#39;).setup({ ensure_installed = {\u0026#34;javascript\u0026#34;, \u0026#34;lua\u0026#34;, \u0026#34;json\u0026#34;, \u0026#34;html\u0026#34;, \u0026#34;css\u0026#34;, \u0026#34;typescript\u0026#34;, \u0026#34;markdown\u0026#34;, \u0026#34;go\u0026#34;, \u0026#34;python\u0026#34;}, sync_install = false, auto_install = true, highlight = {enable = true} }) Para que no se haga muy largo este post, haremos un video en el canal de YouTube de la comunidad para que sea m√°s f√°cil y visual el uso de Nvim.\nEspero que este posts les sea de utilidad para aprender. Tambien les dejo mi configuraci√≥n de Nvim en donde explico qu√© es, porque lo uso y todos los plugins que utilizo en mi d√≠a a d√≠a.\n"},{"href":"https://gophers-latam.github.io/posts/2023/12/manejo-de-memoria-101.-memoria-virtual-stack-y-heap/","title":"Manejo de memoria 101. Memoria virtual, Stack y Heap","body":" Puzzle. imagen de dominio p√∫blico gentileza piqsels. https://www.piqsels.com/en/public-domain-photo-smyfi Que Go tiene un recolector de basura integrado lo hemos escuchado muchas veces. Significa que no tenemos que preocuparnos de liberar la memoria que nuestra aplicaci√≥n usa, pero ¬øDeberiamos entender el ciclo de uso de memoria de nuestras aplicaciones? ¬øEl recolector de basura nos da derecho a olvidar y usar y abusar de ese recurso?\nY, primero que nada ¬øQue diablos es la memoria de la que tanto se habla?\nRenuncia de responsabilidades. No es trivial entender la forma en que los computadores trabajan. En aras de poder difundir intentaremos simplificar lo mas posible, en ocasiones, mas alla de lo recomendado. Muchos programadores hemos llegado a Go desde lenguajes de tipado d√©bil, donde hemos tendido a mirar recursos como la memoria como si fueran gratuitos. Nada mas lejos de la verdad, como dice el viejo dicho No hay tal cosa como un almuerzo gratis y si queremos convertirnos en programadores m√≠nimamente competentes debemos tener al menos una idea b√°sica sobre la forma en que se manejan dichos recursos. He ah√≠ la raz√≥n de este art√≠culo.\nMemoria virtual Aquellos que ya tengan la escritura de algunos programas a su haber saben que cuando declaramos una variable, lo que estamos haciendo es asignar un identificador a una direcci√≥n de memoria en la que guardaremos datos (si nunca ha declarado una variable, hagase un favor y vaya al tour de go).\nMas o menos cuando hablamos de memoria todos pensamos en una grilla homogenea, con direcciones para acceder a cada casilla comodamente.\nPues bien, esa direcci√≥n de memoria no sali√≥ del aire por generaci√≥n espontanea, existe f√≠sicamente de alguna forma en alguna parte.\nEn realidad, lo que llamamos memoria es una abstracci√≥n proporcionada por el sistema operativo, la cual oculta diferentes medios de almacenamiento.\nLos registros del procesador\nLa cach√© del procesador\nRAM\nArchivos en disco\nEtc.\nEn terminos generales, no sabemos en cual de estos medios de almacenamiento quedar√° almacenada nuestra variable. Solo sabemos que le hemos pedido memoria al sistema y que este nos la present√≥ adecuadamente para lograr nuestro objetivo. Claro, en aras de la eficiencia hay una gran probabilidad de que nuestro dato haya quedado guardado en RAM.\nEsta abstracci√≥n a la que hicimos referencia, es lo que llamamos memoria virtual, es administrada por el sistema operativo y es un recurso el cual debe ser solicitado.\nMemoria virtual es una abstracci√≥n que provee a cada proceso la ilusi√≥n de que tiene uso exclusivo sobre la memoria principal. Bryant, R. E. \u0026amp; O‚ÄôHallaron, D. R. (2016). Computer System: A Programmer‚Äôs Perspective (Third global edition). Pearson Education Limited.\nLa organizaci√≥n en forma de Celdas de memoria que nos es tan familiar es propia de la memoria virtual y como se imagina para que pueda funcionar se necesita una sofisticada interacci√≥n entre el sistema operativo y el hardware. Esta interacci√≥n se basa en un mapeo, direccionamiento o traslaci√≥n entre las direcciones de la memoria virtual y el medio f√≠sico donde realmente se encuentre nuestro dato.\nCuando se ejecuta un programa, este tiene una visi√≥n uniforme de la memoria, la que llamamos Espacio de direcciones virtual, y dentro de este espacio hay dos √°reas bien definidas que nos son de vital importancia.\nStack y Heap Stack El Stack es una regi√≥n de la memoria que es localizada para cada hilo de ejecuci√≥n de nuestros programas. En el contexto de Go, decimos que cada gorutina tiene su propio Stack. Su objetivo es contener variables locales, argumentos y valores de retorno de funciones, etc.\nCuando se invoca una funci√≥n, se agrega una nueva capa en el Stack y cuando la funci√≥n termina, esa capa se quita a su vez del Stack.\nLlamamos Localizaci√≥n/Allocation al proceso de reservar memoria para almacenar nuestros datos, y Deslocalizaci√≥n/Deallocation al proceso de liberarla una vez que ya no la necesitamos. El Stack tiene la ventaja de que permite acceder r√°pidamente a la memoria, ¬°claro! porque los datos m√°s recientes est√°n siempre en la capa superior. Adem√°s, como cuando una funci√≥n termina su ejecuci√≥n, su capa asociada en el Stack se quita, ¬°La memoria utilizada para los datos en esa capa se ve autom√°ticamente deslocalizada!\nEl Stack empieza con espacio pre-localizado de un tama√±o fijo, si el runtime detecta que se est√° quedando sin espacio, localiza m√°s y como la memor√≠a est√° localizada de antemano, guardar datos en el Stack es barato y autom√°tico.\nPara que una variable sea asignada en el Stack, deben cumplirse una serie de requisitos:\nTama√±o fijo, conocido en tiempo de compilaci√≥n\nEl runtime de Go debe ser capaz de determinar completamente su ciclo de vida\nSu tama√±o no debe superar la capacidad m√°xima del Stack (mas las salvaguardas del runtime)\nEl Stack es r√°pido, localizar y dealocalizar en el es barato. Si estas y otras condiciones no son cumplidas, la variable escapar√° al Heap.\nHeap El Heap es el √°rea del espacio de direcciones virtual que el runtime de Go solicita para almacenar los datos al ejecutar nuestro programa. El Heap crece din√°micamente y su objetivo es contener los datos que necesitamos persistan mas all√° del tiempo de vida de una funci√≥n o que son muy grandes para ser alojados en el stack.\nEl que nuestros datos escapen al Heap es costoso porque implica una localizaci√≥n, lo que significa que:\n1 Se verifica que el Heap tenga suficiente capacidad para el valor que almacenaremos en el.\n2 Si el punto 1 no se cumple, se debe solicitar m√°s memoria al sistema operativo para el Heap. Se produce una System Call solicitando el recurso. En el mundo real este paso se realiza independientemente. El runtime monitorea constantemente el Heap y algunos algoritmos implementan un una meta, un l√≠mite de memoria, que una vez alcanzado o sobrepasado produce la solicitud de mas recursos al sistema operatvo.\n3 Se localiza la memoria en el Heap (por simplicidad incluyamos en este apartado la escritura de los datos que guardaremos).\n4 Se almacena en el Stack un puntero a la direcci√≥n de memoria inicial de la localizaci√≥n en el Heap.\nEl Heap es flexible, pero la flexibilidad viene con un costo ¬°Todo esto es bastante trabajo para guardar un monton de datos! ¬°Sea parsimonioso! Si, porque localizar en el Heap, si bien proporciona muchas ventajas, tiene un costo. Es por eso que en el ecosistema de Go usted encontrar√° librer√≠as que se jactan de tener cero localizaciones, es decir, estan escritas tan cuidadosamente que no guardan datos en el Heap, s√≥lo usan el Stack.\nEscapando al Heap Revisemos el siguiente c√≥digo\nmain.go\npackage main func retString() string { retVal := \u0026#34;achu\u0026#34; return retVal } Hemos definido una funci√≥n que devuelve un string. Construyamos un benchmark para que la podamos analizar.\nmain_test.go\npackage main import ( \u0026#34;testing\u0026#34; ) func Benchmark_retString(b *testing.B) { var a string b.ResetTimer() for i := 0; i \u0026lt;= b.N; i++ { a = retString() } b.StopTimer() b.Log(a) b.StartTimer() } Al ejecutar el benchmark veremos algo parecido al siguiente reporte\n$ go test -bench . -benchmem goos: linux goarch: amd64 pkg: exmem cpu: Intel(R) Core(TM) i7-10700 CPU @ 2.90GHz Benchmark_retString-16 1000000000 0.3356 ns/op 0 B/op 0 allocs/op Donde el benchmark nos informa con 0 allocs/op que han ocurrido 0 localizaciones al heap.\nReunamos m√°s informaci√≥n. Agreguemos al comando el flag -gcflags \u0026quot;-m -m\u0026quot; que har√° que el compilador realice un an√°lisis de escape, el cual nos informar√° de movimientos de datos al heap.\n$ go test -gcflags \u0026#34;-m\u0026#34; -bench . -benchmem # exmem [exmem.test] ./main.go:3:6: can inline retString ./main_test.go:13:16: inlining call to retString ./main_test.go:7:26: leaking param: b ./main_test.go:17:7: ... argument does not escape ./main_test.go:17:8: a escapes to heap # exmem.test _testmain.go:37:6: can inline init.0 _testmain.go:45:24: inlining call to testing.MainStart _testmain.go:45:42: testdeps.TestDeps{} escapes to heap _testmain.go:45:24: \u0026amp;testing.M{...} escapes to heap goos: linux goarch: amd64 pkg: exmem cpu: Intel(R) Core(TM) i7-10700 CPU @ 2.90GHz Benchmark_retString-16 1000000000 0.3356 ns/op 0 B/op 0 allocs/op Continua reportandonos 0 localizaciones, pero ha agregado informaci√≥n interesante. Observe la siguiente l√≠nea en el reporte:\n./main_test.go:17:8: a escapes to heap Nos indica que la variable a escapa al Heap ¬°Y nos dice el lugar exacto donde este escape ocurre!\nLa l√≠nea 17 de nuestro archivo de benchmark, precisamente donde pasamos la variable al logger.\nEsto demuestra que el escape no es producto de nuestro c√≥digo pues el log de la variable est√° ah√≠ solo como medio informativo y no es parte del mismo.\nConstruyamos otra funci√≥n, esta vez una que devuelva un puntero a una variable local.\nfunc rePointerToString() *string { retVal := \u0026#34;achu\u0026#34; return \u0026amp;retVal } Y agreguemos el benchmark correspondiente.\nfunc Benchmark_retPointerToString(b *testing.B) { var a *string b.ResetTimer() for i := 0; i \u0026lt;= b.N; i++ { a = rePointerToString() } b.StopTimer() b.Log(a) b.StartTimer() } Al ejecutar el benchmark veremos un reporte parecido a lo que sigue:\ngoos: linux goarch: amd64 pkg: exmem cpu: Intel(R) Core(TM) i7-10700 CPU @ 2.90GHz Benchmark_retPointerToString Benchmark_retPointerToString-16 50917658\t24.86 ns/op\t16 B/op\t1 allocs/op PASS ok exmem\t1.292s ¬°Una localizaci√≥n que reserva 16 bytes! Agreguemos un nivel m√°s al an√°lisis con -gcflags \u0026quot;-m\u0026quot;\n./main.go:3:6: can inline retString ./main.go:8:6: can inline rePointerToString ./main_test.go:13:16: inlining call to retString ./main_test.go:27:24: inlining call to rePointerToString ./main.go:9:2: moved to heap: retVal ./main_test.go:7:26: leaking param: b ./main_test.go:17:7: ... argument does not escape ./main_test.go:17:8: a escapes to heap ./main_test.go:21:35: leaking param: b ./main_test.go:27:24: moved to heap: retVal ./main_test.go:31:7: ... argument does not escape # exmem.test _testmain.go:39:6: can inline init.0 _testmain.go:47:24: inlining call to testing.MainStart _testmain.go:47:42: testdeps.TestDeps{} escapes to heap _testmain.go:47:24: \u0026amp;testing.M{...} escapes to heap goos: linux goarch: amd64 pkg: exmem cpu: Intel(R) Core(TM) i7-10700 CPU @ 2.90GHz Benchmark_retPointerToString Benchmark_retPointerToString-16 49800909 25.77 ns/op 16 B/op 1 allocs/op Otra vez podemos ver varias cosas interesantes:\n./main.go:9:2: moved to heap: retVal ... ./main_test.go:17:8: a escapes to heap ... ./main_test.go:27:24: moved to heap: retVal ... En el archivo main.go, donde definimos la funci√≥n rePointerToString el an√°lisis de escape nos informa que en la l√≠nea 9, donde definimos a la variable retVal como un string, el compilador ha movido la variable al Heap ¬°Cuando a√∫n no hemos devuelto su puntero! ¬°Lo hacemos recien en la l√≠nea 10! ¬°Claro! el compilador ha detectado que devolveremos un puntero al valor string almacenado en la variable local, por lo que ha determinado almacenar a la variable en el Heap directamente ¬°Aun antes de que se produzca el retorno del puntero!\nHablar sobre memoria y otros temas relacionados con arquitectura de computadores es apasionante, pero es para nunca terminar.\nRecapitulando, hemos dado un recorrido introductorio a vuelo de pajaro sobre la memoria revisando al Stack y al Heap, con algunos ejemplos en c√≥digo. Conocimos al flag -gcflags \u0026quot;-m\u0026quot; para agregar an√°lisis de escape a nuestros tests y benchmarks.\nSi le gust√≥ este art√≠culo no olvide compartirlo.\n"},{"href":"https://gophers-latam.github.io/posts/2023/12/fuga-de-gorutinas/","title":"Fuga de gorutinas","body":" Fugas. imagen de dominio p√∫blico gentileza pxfuel. https://www.pxfuel.com/en/free-photo-ojgpw Sabemos que las gorutinas son una de las mas importantes primitivas que Go pone a nuestra disposici√≥n para el manejo de concurrencia. Por eso se hace necesaria una forma de prevenir fugas de gorutinas.\nSi aun no empieza a estudiar concurrencia en Go ¬°Le sugerimos ver este video de la comunidad antes de leer este art√≠culo! Una fuga o leak de gorutinas es cuando nuestra aplicaci√≥n crea gorutinas sin tener el cuidado de terminarlas correctamente.\nObservemos el siguiente ejemplo. Seguramente reconocer√° el problema, en este caso estamos enviando informaci√≥n por un canal y no tenemos a nadie que consuma dicho canal.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func send() int { n := rand.Intn(1000) time.Sleep(200 * time.Millisecond) return n } func submit() int { ch := make(chan int) go func() { ch \u0026lt;- send() }() go func() { ch \u0026lt;- send() }() go func() { ch \u0026lt;- send() }() go func() { ch \u0026lt;- send() }() return \u0026lt;-ch } func submitAll() { for i := 0; i \u0026lt; 5; i++ { submit() } } func main() { submitAll() fmt.Printf(\u0026#34;n√∫mero de gorutinas: %d\\n\u0026#34;, runtime.NumGoroutine()) } Si ejecutamos este programa veremos lo siguiente:\n$ go run main.go n√∫mero de gorutinas: 16 Imprime n√∫mero de gorutinas: 16 ¬øPor que raz√≥n? Porque el contenido del loop se itera 4 veces y en cada iteraci√≥n engendra 4 gorutinas en la funci√≥n submit. Ingenuamente podriamos estar esperando que al salir del √°mbito de la funci√≥n submit las gorutinas se hubiesen cerrado ¬°Pero no es as√≠! ¬°Siguen corriendo al final de su proceso como lo demuestra la impresi√≥n!\nUna fuga o leak de gorutinas es cuando nuestra aplicaci√≥n crea gorutinas sin tener el cuidado de terminarlas correctamente. Ahora bien, si nuestra aplicaci√≥n terminara en este punto, no habr√≠a problema alguno, pues al acabar su ejecuci√≥n ya es responsabilidad del sistema operativo realizar las labores de limpieza. Pero muchas veces usamos Go para construir aplicaciones que se ejecutan continuamente sin parar y que se espera que no se detengan, como servicios, apis, etc. En este tipo de aplicaciones, un escenario como el presentado en el ejemplo es insostenible.\nGo reserva una cantidad de memoria espec√≠fica inicial para que las gorutinas usen como su stack, si bien esta cantidad puede variar de versi√≥n en versi√≥n, la cantidad actual se puede revisar en el repositorio de GO\nEste stack puede ir creciendo seg√∫n el proceso que se ejecute dentro de la gorutina.\nEl problema Entonces, ¬øQue pasar√° si nuestra aplicaci√≥n sufre de fuga de gorutinas y engendra 100000 de ellas durante un peri√≥do de un a√±o sin terminarlas correctamente?\nPues asumiendo optimistamente que el proceso que se ejecuta dentro de nuestras gorutinas fugadas devuelven correctamente la memoria, y que el stack asignado a cada una de ellas sigue teniendo un tama√±o de 2kB, tendriamos para ese momento cerca de 200MB de memoria usada por la aplicaci√≥n que no podr√°n ser recuperados por el recolector de basura ¬°Porque las gorutinas todav√≠a est√°n ejecutandose! ¬°Porque nunca nos aseguramos de terminarlas correctamente!\nSi no cuidamos de terminar correctamente las gorutinas que nuestra aplicaci√≥n engendra, corremos el riesgo de enfrentar Out Of Memory Errors Si ejecutamos nuestra aplicaci√≥n en alg√∫n tipo de contenedor o m√°quina virtual con un l√≠mite duro de memor√≠a, esto puede llegar a ocasionar out of memory errors\n¬øQue podemos hacer?\nPreviniendo fugas de gorutinas Inevitablemente debemos aprender y convertirnos en expertos en el modelo de memoria de Go y en su modelo de concurrencia. Esto es de vital importancia, pues de la misma forma que un carpintero es responsable de usar de forma segura su sierra circular, taladro y otros implementos, nosotros como programadores somos responsables de usar correctamente las herramientas de nuestro oficio.\nEn esto cae la construcci√≥n de tests y benchmarks y el uso profilactico de herramientas de perfilado como pprof asegurandonos de que las pruebas se realicen por un periodo de tiempo conveniente, pues no es lo mismo perfilar un servicio el mismo d√≠a en que lo lanzamos a correr, que dos meses despu√©s.\nOtra herramienta muy √∫til es goleak del equipo de Uber Go, que presenta una forma muy simple de testear que nuestras gorutinas se cierren correctamente.\nSe usa de la siguiente forma:\n1 Debemos importarla a nuestro proyecto $ go get -u go.uber.org/goleak\n2 Debemos construir un test que incluya el flujo completo de nuestras gorutinas. Usaremos el mismo ejemplo anterior\nImportamos la utilidad y nos aseguramos de invocarla usando defer para que se garantice su ejecuci√≥n al final de nuestro proceso.\npackage main import ( \u0026#34;testing\u0026#34; \u0026#34;go.uber.org/goleak\u0026#34; ) func TestGorutineLeak(t *testing.T) { defer goleak.VerifyNone(t) for i := 0; i \u0026lt; 4; i++ { submitAll() } } ¬°Y listo! Al ejecutar el test, si goleak detecta fugas de gorutinas, el test fallar√°\n$ go test ./... === RUN TestGorutineLeak /home/jacobopus/projects/go/goru/main_test.go:15: found unexpected goroutines: [Goroutine 7 in state chan send, with goru.submit.func1 on top of the stack: goru.submit.func1() /home/jacobopus/projects/go/goru/main.go:19 +0x30 created by goru.submit in goroutine 6 /home/jacobopus/projects/go/goru/main.go:19 +0x66 ] --- FAIL: TestGorutineLeak (4.46s) FAIL Puede revisar la documentaci√≥n de goleak para descubrir otras formas de uso.\nNo olvide compartir este articulo si fue de su agrado.\n"},{"href":"https://gophers-latam.github.io/posts/2023/10/el-tour-de-go-ahora-en-espa%C3%B1ol/","title":"El tour de Go ahora en Espa√±ol","body":" Tour de Go en Espa√±ol ¬°Logramos algo incre√≠ble como comunidad! La traducci√≥n del tour de Go al espa√±ol. Estamos emocionados de compartir con todos ustedes el incre√≠ble logro que hemos alcanzado juntos: la completa traducci√≥n del tour de Go al espa√±ol.\nEste proyecto fue un esfuerzo colaborativo en el que nuestra comunidad contribuy√≥ con su tiempo y conocimiento para hacer que esta herramienta est√© disponible para toda la comunidad hispanohablante. ¬°El resultado es asombroso!\n¬øQu√© es El Tour de Go? üë©‚Äçüíªüë®‚Äçüíª Para aquellos que a√∫n no lo conocen, el \u0026ldquo;Tour de Go\u0026rdquo; es una excelente introducci√≥n al lenguaje de programaci√≥n Go. Proporciona ejemplos interactivos y explicaciones detalladas, lo que lo convierte en una herramienta invaluable para aprender Go.\nEl poder de la colaboraci√≥n üë• La clave de este logro fue la colaboraci√≥n. Cada uno de nosotros aport√≥ con sus habilidades y conocimientos para llevar a cabo esta traducci√≥n. Desde los que realizaron las primeras traducciones hasta aquellos que revisaron y pulieron cada detalle, cada uno de ustedes fue fundamental.\n¬øQu√© significa esto para la comunidad? üí° La traducci√≥n del tour al espa√±ol no solo significa que m√°s personas tendr√°n acceso a esta valiosa herramienta, sino que tambi√©n fortalece nuestra comunidad y nos posiciona como un grupo que puede lograr grandes cosas cuando trabajamos juntos.\n¬øQu√© sigue? üõ†Ô∏è Nuestro trabajo no termina aqu√≠. Continuaremos buscando maneras de contribuir y crecer como comunidad. Si tienes ideas o proyectos en mente, ¬°no dudes en compartirlas!\nUna vez m√°s, felicitaciones a todos los que participaron en este proyecto. ¬°Han demostrado el incre√≠ble poder de la comunidad de Gophers Latam!\n¬°Sigamos construyendo juntos! üöÄ Tour de Go Link del repositorio: https://github.com/gophers-latam/go-tour-es\nLink profesional sobre la comunidad: https://es.linkedin.com/posts/thiago-mowszet_github-gophers-latamgo-tour-es-traducci%C3%B3n-activity-7118450478593536000-JlrR\n"},{"href":"https://gophers-latam.github.io/posts/2023/03/handlers-con-timeout/","title":"Handlers Con Timeout","body":" go handlers En algunas oportunidades, vamos a necesitar un comportamiento muy determin√≠stico en nuestras APIs, ya sea porque el negocio as√≠ lo requiere o los clientes. Tal vez, un comportamiento que se mantenga alejado de cualquier sorpresa, puede ser el m√°ximo de duraci√≥n que le queremos dejar como ventana para que un respuesta sea entregada, en caso de excederlo, ahora si como el t√≠tulo lo dice, devolvemos un timeout\u0026hellip; pero, qu√© es un timeout?\nEn principio sabemos que contamos con 2 estados para representarlo, pero no se parecen mucho ya que est√°n en centenas distintas, unos es 408 request timeout y el otro es 504 Gateway timeout. Si leemos un poco las especificaciones, ninguno de los dos nos calza justo para lo que queremos, el 408 nos dice que el cliente \u0026ldquo;se tard√≥ demasiado para enviar su request\u0026rdquo;, desde la RFC dice lo siguiente:\nThe client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.\nY para su contraparte del lado del servidor:\nThe server was acting as a gateway or proxy and did not receive a timely response from the upstream server.\nEntonces, para la responder la pregunta, concluimos que un timeout es que esperamos demasiado por algo, y no sucedi√≥, ademas, lo consideramos un error.\nC√≥mo hacemos nuestras funciones de Timeout? En los lenguajes de programaci√≥n modernos, encontramos built-in algunas formas de manejar estos casos de uso. En Golang, por ejemplo el paquete context tiene constructores para crear uno que expire y se cancele despu√©s de cierto tiempo.\nDentro del paquete net/http tambi√©n nos encontramos con muchos timeouts como por ejemplo en la struct http.Client para hacer requests y http.Server es otra que tampoco se queda afuera de tener este tipo de configuraci√≥n.\nPor ahora, tenemos: context, http.Client y Server, servidores TCP y UDP, etc. Podemos resumir que siempre que haya una conexi√≥n hacia fuera (ya sea cliente o servidor) vamos a poder configurar un timeout.\nC√≥mo nos sirven en los web handlers? Antes, debemos aclarar que es un middleware, en cualquier lenguaje, ya que es un concepto y no una implementaci√≥n espec√≠fica de Golang.\nEntonces, decimos que son funciones con la misma firma que un handler (o controlador web), que recibe los mismos par√°metros para operar como una petici√≥n HTTP. Al ser iguales, nos permite ejecutarlo previamente de una forma sencilla y pre-ejecutar operaciones que nos ayuden a nuestro negocio. Un claro ejemplo son validaciones de token JWT, agregar request ID unicos, sumarle datos al contexto (esto si es mas estilo gopher). En nuestro caso, vamos a tener un middleware que se encargue de reemplazar el contexto, por otro que tenga un timeout, para que no tarde mas de tanto tiempo y si no, falla. Nos va a ayudar a garantizar un tiempo de respuesta de m√°xima, por las buenas o por las malas.\nLo llevamos a c√≥digo Como middleware, podemos usar uno que ya existe y est√° dentro del paquete http, es http.Timeout y dentro de su firma, vamos a pasarle un http.Handler, el tiempo de espera que vamos a soportar y por √∫ltimo (este no me gusta mucho) un mensaje como string, donde nos quita un poco de flexibilidad, a mi entender, []byte nos dar√≠a un espectro mas amplio a la hora de retornar los valores.\nPodemos implementarlo como un wrapper general a todo el multiplexer y que todos ejecuten el middleware, este tiene como ventaja que escribimos una sola vez, pero perdemos granularidad. func main() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { //.... }) muxWithMiddleware := http.TimeoutHandler(mux, time.Second*5, \u0026#34;timeout!\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, muxWithMiddleware)) } Por √∫ltimo, tenemos otro camino, para tener un control esperc√≠fico en cada handler que expongamos. func main() { mux := http.NewServeMux() helloHandler := http.TimeoutHandler(wrapHandlerFunc(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { _, _ = w.Write([]byte(\u0026#34;hello with timeout!\u0026#34;)) })), time.Second*5, \u0026#34;timeout\u0026#34;) mux.Handle(\u0026#34;/\u0026#34;, helloHandler) } func wrapHandlerFunc(handler http.Handler) http.Handler { wrapped := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) handler.ServeHTTP(w, r) }) return wrapped } Conclusiones Vemos la flexibilidad que tenemos para exponer funciones en un servior web que tenemos en Golang. Siempre nos da muchas facilidades y opciones, a su vez, puede ser un poco confuso porque no sabemos bien cual usar. Como peque√±o consejo, no nos fritemos la cabeza pensando y comparando, tan solo elijamos una con un an√°lisis superficial y despues nos queda el aprendizaje.\nPara cerrar el tema t√©cnico, estamos re-utilizando una funcion de la stdlib de Go, por lo que no es necesario que nostros pensemos esa l√≥gica, tambi√©n, muchos de los Frameworks web como Echo, Gin y Fiber (seguramente entre varios otros) ya traen sus middleware de timeout y es de una implementacion muy similar a la que acabamos de ver.\nEspero que les haya gustado la explicaci√≥n! nos vemos dentro de poco y cualquier tema que quieran que tratemos lo pueden dejar en comentarios.\n"},{"href":"https://gophers-latam.github.io/posts/2022/08/intro-go-mistakes-okno/","title":"Intro Go Mistakes Okno","body":" okno Se comparte el concepto o contexto de algunos errores basicos con su definici√≥n acompa√±ado de ejemplo y soluci√≥n.\nIndice: C√≥digo y organizaci√≥n del proyecto C√≥digo y organizaci√≥n del proyecto - Sombreado de variable (shadowing) no deseado La parte de una aplicaci√≥n donde un enlace de nombre es v√°lido. En Go, un nombre de variable declarado en un bloque se puede volver a declarar en un bloque interno. Este principio, llamado sombreado de variable, es propenso a errores.\nEjemplo:\nvar client *http.Client if tracing { client, err := createClientWithTracing() if err != nil { return err } log.Println(client) } else { client, err := createDefaultClient() if err != nil { return err } log.Println(client) } 1 Declarar una variable client 2 Crear un cliente HTTP con tracing habilitado, la variable client est√° sombreada en este bloque 3 Crear un cliente HTTP predeterminado, la variable client tambi√©n se sombrea en este bloque Como resultado, de este ejemplo, la variable externa siempre ser√° nula.\nSoluci√≥n:\nLa primera opci√≥n es usar variables temporales en los bloques internos:\nvar client *http.Client if tracing { c, err := createClientWithTracing() if err != nil { return err } client = c } else { // Same logic } 1 Crear una variable temporal c 2 Asignar esta variable temporal a client Otra opci√≥n es usar el operador de asignaci√≥n (=) en los bloques internos para asignar directamente los resultados de la funci√≥n a la variable. Sin embargo, requiere crear una variable de error ya que el operador de asignaci√≥n solo funciona si ya se ha declarado un nombre de variable:\nvar client *http.Client var err error if tracing { client, err = createClientWithTracing() if err != nil { return err } } else { // Same logic } 1 Declarar una variable de error 2 Usar operador de asignaci√≥n para asignar el *http.Client devuelto a la variable client directamente - C√≥digo anidado innecesario Un aspecto cr√≠tico de la legibilidad es el n√∫mero de niveles anidados. Un c√≥digo se califica como legible en funci√≥n de m√∫ltiples criterios, como el nombrado, la consistencia, el formato, etc. Un c√≥digo legible requerir√° menos esfuerzo cognitivo para mantener un modelo mental; por lo tanto, ser√° m√°s f√°cil de leer y mantener.\nEjemplo:\nTiempo o dificultad para entender la siguiente funci√≥n a detalle.\nfunc join(s1, s2 string, max int) (string, error) { if s1 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s1 is empty\u0026#34;) } else { if s2 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s2 is empty\u0026#34;) } else { concat, err := concatenate(s1, s2) if err != nil { return \u0026#34;\u0026#34;, err } else { if len(concat) \u0026gt; max { return concat[:max], nil } else { return concat, nil } } } } } func concatenate(s1 string, s2 string) (string, error) { // ... } Soluci√≥n:\nHacer la tarea de aplicar legibilidad y consistencia sobre la misma funci√≥n, implementandola de manera diferente:\nfunc join(s1, s2 string, max int) (string, error) { if s1 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s1 is empty\u0026#34;) } if s2 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s2 is empty\u0026#34;) } concat, err := concatenate(s1, s2) if err != nil { return \u0026#34;\u0026#34;, err } if len(concat) \u0026gt; max { return concat[:max], nil } return concat, nil } func concatenate(s1 string, s2 string) (string, error) { // ... } El resultado para requerir menos carga cognitiva. - Mal uso de las funciones init En principio init es una funci√≥n que no toma argumentos y no devuelve ning√∫n resultado (una funci√≥n func()). Cuando se inicializa un paquete, se eval√∫an todas las declaraciones de constantes y variables del paquete. El principal problema reside cuando se ha creado un flujo de uso que se vuelve dificil de entender o seguir y por falta de entendimiento se provocan errores no manejados que se volveran dificiles de mitigar o controlar.\nEjemplo:\nOlvidar o no haber entendido el sentido o punto de entrada para ejecuion de init.\npackage main import \u0026#34;fmt\u0026#34; var a = func() int { fmt.Println(\u0026#34;var\u0026#34;) return 0 }() func init() { fmt.Println(\u0026#34;init\u0026#34;) } func main() { fmt.Println(\u0026#34;main\u0026#34;) } Salida\n1: var 2: init 3: main Ejemplo de flujo usando Redis en base de codigo personal.\nSoluci√≥n:\nHay criterios en sentido idiomatico como:\nEvitar incluir funciones init en codigo que sera probado con paquete de testing.\nNo hacer que sean de ambito global a menos que sea realmente requerido.\nEvitar usar para conexiones a base de datos.\nInvestigar situaciones en las que pueden ser √∫tiles, como definir una configuraci√≥n est√°tica. De lo contrario, y en la mayor√≠a de los casos, manejar las inicializaciones a trav√©s de funciones personalizadas.\nEbook recomendado: 100 Go Mistakes Que trata a fondo algunos errores sobre: Tipos de datos, Estructuras de control, Strings en detalle, Funciones y m√©todos, Manejo de errores, Concurrencia: Fundamentos y Pr√°ctica, Librer√≠a est√°ndar, Pruebas y Optimizaciones\n"},{"href":"https://gophers-latam.github.io/posts/2021/12/ecosistema-lenguage-go/","title":"Ecosistema lenguage Go","body":" json to go Go, tambi√©n conocido como Golang, es un lenguaje de programaci√≥n de tipado est√°tico desarrollado por Robert Griesemer, Rob Pike y Ken Thompson en Google.\nGo es sint√°cticamente similar a C, pero viene con seguridad de memoria, recolecci√≥n de basura, tipificaci√≥n estructural y sincronizaci√≥n al estilo CSP.\nHay dos implementaciones principales:\nEl paquete de alojamiento de Google que se dirige a m√∫ltiples sistemas operativos, dispositivos m√≥viles y WebAssembly.\ngccgo (un front) y GCC\nGo es expresivo, conciso, limpio y eficiente. Los mecanismos simult√°neos facilitan la escritura de aplicaciones que aprovechan al m√°ximo las m√°quinas en red de varios n√∫cleos, mientras que el sistema m√°s nuevo permite crear aplicaciones modulares y flexibles. Compila c√≥digo m√°quina con bastante rapidez, pero tiene la conveniencia de la recolecci√≥n de basura y el poder de reflejar el tiempo de ejecuci√≥n. - Un lenguaje r√°pido, bien tipado y bien proporcionado que act√∫a como un lenguaje interpretado din√°mico.\nNada hace que un programador se emocione m√°s que descubrir un nuevo lenguaje de programaci√≥n. Al examinar el estado actual del software y hardware inform√°tico, podemos ver por qu√© tenemos que cambiar a un nuevo lenguaje como Go. Durante la √∫ltima d√©cada, la potencia de procesamiento en bruto ha aumentado ligeramente y el rendimiento de la frecuencia de la CPU se ha mantenido casi constante durante una d√©cada.\nGo, se libero cuando los procesadores de varios n√∫cleos ya estaban disponibles. Es por eso que Go se hizo pensando en la coordinaci√≥n. Sus mecanismos s√≠ncronos facilitan la escritura de aplicaciones que utilizan m√°s sistemas multin√∫cleo y en red. Si bien el nuevo tipo de sistema Go hace posible construir aplicaciones modulares flexibles, en lugar de centrarse en teor√≠as, en m√©todos del mundo real para construir aplicaciones de pr√≥xima generaci√≥n en la nube, as√≠ como computaci√≥n avanzada y computaci√≥n distribuidas.\nHist√≥rico Go es un lenguaje de programaci√≥n procedimental que se lanz√≥ en 2009 como lenguaje de programaci√≥n de c√≥digo abierto. Actualmente se utiliza en varios sistemas operativos de Google. El Go Compiler es compatible con Linux, Mac OS, Windows y una variedad de sistemas operativos BSD como FreeBSD. En t√©rminos de arquitectura de procesador, la arquitectura X86, la arquitectura X64, la arquitectura ARM y la arquitectura Power espec√≠fica de IBM tambi√©n son compatibles con Go.\nArquitectura Ling√º√≠stica Go tiene muchas herramientas poderosas de an√°lisis est√°tico. Uno de ellos es go fmt, que dise√±a su c√≥digo bas√°ndose en el estilo Go propuesto. Esto puede eliminar muchos comentarios en un proyecto normal y alentar a su equipo a concentrarse en el c√≥digo. Lenguaje de programaci√≥n desarrollado y compilado de forma nativa, que pertenece principalmente a la familia de lenguajes C en t√©rminos de sintaxis b√°sica.\nComo C y C++, est√° compilado en c√≥digo de m√°quina, por lo que no necesitamos entornos como CLR y JVM para ejecutar programas Go. Esto ayuda especialmente al compilar programas grandes. Lenguaje simple y minimalista con dise√±o original de Go para en lugar del cl√°sico Thread a goroutines. En Go, el l√≠mite de tama√±o de pila m√≠nimo se elimina de 4 KB a 8 KB cuando se crea una goroutine.\nDise√±o Go est√° influenciado por C, pero con un mayor √©nfasis en la simplicidad y la seguridad. Esto incluye:\nPatrones de adopci√≥n de sintaxis y entorno que son m√°s comunes en lenguajes din√°micos: Declaraci√≥n de variable corta opcional e introducci√≥n inicial por inferencia de tipo.\nEdici√≥n r√°pida.\nAdministraci√≥n de paquetes remotos (go download) y documentaci√≥n de paquetes en l√≠nea.\nEnfoques distintivos para problemas espec√≠ficos.\nSincronizaci√≥n inicial: procesos de estilo (Gurvin), canales y expresiones selectivas.\nUn sistema de interfaz en lugar de herencia virtual e incrustaci√≥n de tipo en lugar de la herencia no virtual.\nUn kit de herramientas que, de forma predeterminada, crea binarios de interfaz nativa sin dependencias externas.\nLa tendencia a preservar las propiedades del lenguaje es lo suficientemente simple como para mantener en calam la cabeza de un programador, en parte eliminando caracter√≠sticas que son comunes a lenguajes similares.\nGo es Back o Front? El c√≥digo Go se puede ejecutar usando goper.js en el navegador. Pero el hecho es que la mayor√≠a de los desarrolladores recurren a los lenguajes de programaci√≥n Front y JavaScript para desarrollar su lado del cliente. Go es m√°s preferido como lenguaje de respaldo y ofrece un alto rendimiento para el desarrollo simult√°neo de aplicaciones de servidor.\nAlgunas aplicaciones populares desarrolladas en Go Algunos de los proyectos de c√≥digo abierto en Go son:\nCaddy: servidor web HTTP 2 de c√≥digo abierto con capacidad HTTPS autom√°tica\nCockroachDB: una base de datos SQL de c√≥digo abierto, escalable y compatible\nDocker: incluye un conjunto de herramientas de implementaci√≥n de Linux.\nEthereum: implementaci√≥n de Go-Ethereum, m√°quina de bloqueo de m√°quina virtual, Ethereum virtual para criptomoneda Ether\nHugo: un generador de sitios est√°ticos\nInfluxDB: base de datos de c√≥digo abierto para series de datos de alto acceso con requisitos de alto rendimiento\nInterPlanetary File System: un contenido y un protocolo de direccionamiento de medios punto a punto.\nJuju: una herramienta de evaluaci√≥n de servicios de Canonical, paquetes de Ubuntu Linux.\nKubernetes: sistema de gesti√≥n de contenedores\nLightning Network: una red de bitcoins para transacciones r√°pidas de bitcoins.\nMattermost: un sistema de chat en equipo.\nOpenShift: una plataforma de computaci√≥n en la nube proporcionada por Red Hat como servicio.\nSnappy: un administrador de paquetes para Ubuntu Touch desarrollado por Canonical.\nSyncthing: software de sincronizaci√≥n de archivos cliente/servidor de c√≥digo abierto.\nTerraform: una herramienta de c√≥digo abierto para la infraestructura multimedia en la nube proporcionada por HashiCorp.\nEmpresas y sitios notables que han utilizado GO (generalmente junto con otros lenguajes, no exclusivamente) Cacoo: para renderizar paneles de usuario y microservicios usando Go y gRPC.\nChango: una empresa de publicidad que utiliza sistemas de precios en tiempo real.\nCloud Foundry: una plataforma como servicio.\nCloudFlare: se utiliza para el proxy de codificaci√≥n Delta Railgun, su servicio de DNS distribuido, as√≠ como herramientas para encriptaci√≥n, registro, procesamiento de flujo y acceso a sitios SPDY.\nCoreOS: un sistema operativo basado en Linux que utiliza el repositorio Docker y el repositorio rkt.\nDropbox: que ha migrado algunos de sus componentes vitales de Python a Go.\nEthereum: una moneda digital\nGoogle: se utiliza para muchos proyectos, incluido el servidor de descargas (dl.google.com).\nHyperledger Fabric: un proyecto de c√≥digo abierto √∫nico.\nMongoDB: una herramienta para administrar instancias de MongoDB\nNetflix: se utiliza para dos partes de la arquitectura de su servidor.\nNovartis: para sistema de inventario interno\nNutanix: se utiliza para una variedad de microservicios en su empresa Cloud OS.\nPlug.dj: un sitio web interactivo relacionado con la transmisi√≥n de m√∫sica social en l√≠nea.\nSendGrid: un boulder, servicio de entrega de correo electr√≥nico y servicio de gesti√≥n de transacciones.\nSoundCloud: se utiliza para \u0026ldquo;docenas de sistemas\u0026rdquo;.\nEmpalme: se utiliza para todo el backend (API y analizadores) en su plataforma de colaboraci√≥n musical en l√≠nea.\nThoughtWorks: Algunas herramientas y aplicaciones para entrega continua y mensajer√≠a instant√°nea (CoyIM).\nTwitch.tv: para el sistema de chat basado en IRC (migraci√≥n desde Python).\nUber: para manejar grandes vol√∫menes de consultas basadas en geovallas\nGo Features Go compila c√≥digo como lenguajes de bajo nivel como C++/C. Esto significa que funciona casi tan bien como lenguajes de bajo nivel. Tambi√©n utiliza la recolecci√≥n de basura para recolectar y eliminar objetos.\nEl gr√°fico siguente muestra que Go es casi tan eficiente como C++/C, mientras mantiene la sintaxis simple como Ruby, Python y otros lenguajes. Esta es una situaci√≥n en la que todos ganan para los humanos y los procesadores! El alto rendimiento como C++/C y Java proporciona una sincronizaci√≥n altamente eficiente para codificar en t√©rminos divertidos como Python y Perl. El software optimizado puede ejecutarse en hardware m√°s barato y lento, como los dispositivos IoT, y generalmente tiene un mayor impacto en la experiencia del usuario final. El modelo de memoria Go agrega una nueva regla para enviar y recibir canales de b√∫fer para indicar expl√≠citamente que un canal de b√∫fer puede usarse como un simple spammer.\nDescripci√≥n general de las caracter√≠sticas principales del lenguaje:\nCompilaci√≥n: Go genera compilaciones binarias para sus aplicaciones con todas las dependencias. No se requiere instalaci√≥n de traductor o runtime.\nRecolecci√≥n de basura: Para recolectar desperdicios de baja latencia, opta por una administraci√≥n autom√°tica de memoria que sea eficiente y sincr√≥nica. La gesti√≥n de la memoria es intencionadamente m√°s f√°cil que C y C++. Los objetos dedicados recolectan basura de forma din√°mica.\nSeguro: Go es un lenguaje de tipado est√°tico que admite la seguridad de tipos. El compilador detecta los errores antes de la ejecuci√≥n.\nSintaxis similar a C: La sintaxis Go recuerda a la familia C, pero con solo 25 palabras clave simples, es f√°cil de analizar sin tablas/s√≠mbolos de informaci√≥n de tipo y un dise√±o de notificaci√≥n similar a Pascal.\nVarios paradigmas: Go admite varios patrones de programaci√≥n, incluida la programaci√≥n esencial, orientada a objetos (OOP) y la programaci√≥n funcional.\nLibrer√≠a est√°ndar: Go tiene una potente librer√≠a est√°ndar de paquetes para respaldar el desarrollo de aplicaciones Go.\nDocumentaci√≥n sencilla: GoDoc es una herramienta de an√°lisis de c√≥digo est√°tico que genera documentos est√°ndar simplificados directamente desde el c√≥digo.\nSoporte de pruebas naturalmente: Soporte de prueba integrado en la librer√≠a est√°ndar. Sin necesidad de dependencia adicional Si tiene un archivo llamado thing.go, escriba sus pruebas en otro archivo llamado thing_test.go y ejecute \u0026ldquo;go test\u0026rdquo;.\nGo Tools La distribuci√≥n principal de Go incluye herramientas para crear, probar y analizar c√≥digo:\ngo build: crea un binario usando solo sus archivos fuente.\ngo test: se utiliza para pruebas unitarias y microbenchmarks.\ngo fmt: se utiliza para formatear el c√≥digo.\ngo get: se utiliza para recuperar e instalar paquetes remotos.\ngo vet: un analizador est√°tico que busca posibles vulnerabilidades o errores en el c√≥digo.\ngo run: un atajo para construir y ejecutar c√≥digo directamente.\ngo doc: para mostrar documentos o enviarlos a trav√©s de HTTP\ngo rename: se utiliza para renombrar variables, funciones, etc. en tipo seguro.\ngo generate: un m√©todo est√°ndar para llamar a un generador de c√≥digo\nTambi√©n incluye soporte de depuraci√≥n y perfiles, herramientas de medici√≥n de tiempo de ejecuci√≥n. El ecosistema de herramientas de terceros se ha agregado a la distribuci√≥n est√°ndar, incluido gocode, que permite completar autom√°ticamente el c√≥digo en muchos editores de texto. goimports (por un miembro del equipo de Go) que autom√°ticamente elimina o agrega paquetes seg√∫n sea necesario, y errcheck, que detecta errores de c√≥digo y puede ignorarlos. Hay complementos para agregar soporte de idioma en algunos editores de texto. Hay varios IDE disponibles, incluidos LiteIDE y el \u0026ldquo;Go IDE multiplataforma\u0026rdquo; y GoLand.\nAplicaciones del lenguaje Go est√° dise√±ado espec√≠ficamente como lenguaje de programaci√≥n para grandes sistemas distribuidos y servidores de red altamente escalables. En este sentido, reemplaza a C++ y Java en la pila de software de Google. Muchos equipos buscan crear nuevos servidores en Go. Algunos incluso est√°n migrando bases de c√≥digo existentes. Algunas de las tecnolog√≠as de Google que utiliza a diario tienen componentes escritos en Go.\nDado que este es un lenguaje de programaci√≥n relativamente nuevo, muchos preguntan para qu√© es adecuado.\nUn vistazo a algunos de sus beneficios:\nIdeal para el desarrollo web\nExcelente para scripts de l√≠nea de comandos\nSe puede utilizar para aplicaciones de servidor de red.\nSe puede utilizar para el desarrollo de front-end.\nLos desarrolladores disfrutan usando Go porque tiene un entorno de desarrollo completo, y aprender Go es muy f√°cil, incluso para desarrolladores sin experiencia. Una de las razones de esto se debe al gran ecosistema de herramientas, por lo que es muy √∫til para proyectos grandes y conjuntos. Esto lo convierte en una excelente opci√≥n para programar software propietario. Si se est√° buscando m√°s beneficios, Go fue creado y es mantenido por Google, que tiene una de las infraestructuras de nube m√°s importantes del mundo y puede ser a gran escala.\nData Science Es una ciencia multidisciplinaria que utiliza m√©todos, procesos, algoritmos y sistemas cient√≠ficos para extraer conocimientos e ideas de datos estructurados y no estructurados. La ciencia de datos es el concepto de combinar estad√≠sticas, an√°lisis de datos, aprendizaje autom√°tico y m√©todos relacionados para comprender y analizar fen√≥menos reales con datos. Extrae t√©cnicas y teor√≠as que han surgido de muchos campos de las matem√°ticas, la estad√≠stica, la inform√°tica y la ciencia de la informaci√≥n. El ganador del premio Turing, Jim Gray, ve la ciencia de datos como el \u0026ldquo;cuarto modelo\u0026rdquo; de la ciencia (experimental, te√≥rico, computacional y ahora basado en datos) y afirma que \u0026ldquo;todo lo relacionado con la ciencia est√° cambiando debido al impacto de la tecnolog√≠a de la informaci√≥n\u0026rdquo;.\nEn la actualidad, a menudo se usa indistintamente con conceptos anteriores, como an√°lisis empresarial, inteligencia empresarial, modelado de previsi√≥n y estad√≠sticas. Si bien muchos programas acad√©micos ahora tienen un t√≠tulo en ciencia de datos, no existe un consenso sobre la definici√≥n del contenido curricular apropiado. Sin embargo, muchos proyectos de ciencia de datos y Big Data no han podido lograr resultados √∫tiles, a menudo debido a la falta de gesti√≥n y utilizaci√≥n de recursos.\n¬´ Go demuestra cada vez pruebas m√°s r√°pidas, codificaci√≥n f√°cil en lenguajes de programaci√≥n concurrentes altamente eficientes. Por lo general, es la pr√≥xima generaci√≥n de ciencia de datos, aprendizaje autom√°tico e inteligencia artificial, porque existe un gran equilibrio entre la productividad y la retenci√≥n de c√≥digo. Muchos prototipos de cient√≠ficos de datos, que luego son transferidos a producci√≥n por otra persona, deja que Go haga ambas cosas. ¬ª\n"},{"href":"https://gophers-latam.github.io/posts/2021/08/go-talks/","title":"Go Talks","body":" talks Este post contiene charlas de Go que se pueden leer siguiendo los vinculos de cada t√≠tulo listado.\n2019 playground-v3.slide: Playground v3 2017 state-of-go-may.slide\nexporting-go\nstate-of-go-aug\n2016 refactor.article: Codebase Refactoring (with help from Go)\napplicative.slide: Program your next server in Go\nasm.slide: The Design of the Go Assembler\nstate-of-go.slide: The State of Go\ntoken.slide: Stacks of Tokens\nprototype-your-design\n2015 dynamic-tools.slide: Go Dynamic Tools\ngo-for-java-programmers.slide: Go for Java Programmers\ngo4cpp.slide: Go for C++ developers\ngofmt-cn.slide: gofmt ÁöÑÊñáÂåñÊºîÂèò\ngofmt-en.slide: The Cultural Evolution of gofmt\ngogo.slide: Go in Go\ngophercon-go-on-mobile.slide: Go on Mobile\ngophercon-goevolution.slide: The Evolution of Go\ngotham-grpc.slide: gRPC Go\nhow-go-was-made.slide: How Go was made\njson.slide: JSON, interfaces, and go generate\nkeeping-up.slide: Keeping up with the Gophers\nsimplicity-is-complicated.slide: Simplicity is Complicated\nstate-of-go.slide: The State of Go\ntricks.slide: Stupid Gopher Tricks\n2014 c2go.slide: Go, from C to Go\ncamlistore.slide: - Camlistore: Android, ARM, App Engine, anywhere.\ncompiling.slide: - Go: Easy to Read, Hard to Compile\ndroidcon.slide: Go on Android\ngo1.3.slide: Toward Go 1.3\ngo4gophers.slide: Go for gophers\ngo4java.slide: Go for Javaneros (Java√Østes?)\ngocon-tokyo.slide: - Go: 90% Perfect, 100% of the time.\ngotham-context.slide: Cancelation, Context, and Plumbing\ngothamgo-android.slide: Go on Android\nhammers.slide: Gophers With Hammers\nhellogophers.slide: Hello, Gophers!\nnames.slide: What\u0026rsquo;s in a name?\norganizeio.slide: Organizing Go code\nplayground.slide: Inside the Go playground\nreadability.slide: When in Go, do as Gophers do\nresearch.slide: The Research Problems of Implementing Go\nresearch2.slide: More Research Problems of Implementing Go\nstate-of-go.slide: The State of Go\nstate-of-the-gopher.slide: The State of the Gopher (Oct)\nstatic-analysis.slide: Static analysis tools\ntaste.slide: A Taste of Go\ntesting.slide: Testing Techniques\n2013 advconc.slide: Advanced Go Concurrency Patterns\nbestpractices.slide: Twelve Go Best Practices\ndistsys.slide: Go, for Distributed Systems\ngo-sreops.slide: Go Language for Ops and Site Reliability Engineering\ngo1.1.slide: What\u0026rsquo;s new in Go 1.1\ngo4python.slide: Go for Pythonistas\nhighperf.slide: High Performance Apps with Go on App Engine\noscon-dl.slide: dl.google.com: Powered by Go\n2012 10things.slide: 10 things you (probably) don\u0026rsquo;t know about Go\nchat.slide: - Go: code that grows with grace\nconcurrency.slide: Go Concurrency Patterns\ngo-docs.slide: Go docs\ngo1.slide: The Path to Go 1\ngoforc.slide: Go for C programmers\ninsidepresent.slide: Inside the \u0026ldquo;present\u0026rdquo; tool\nsimple.slide: - Go: a simple programming environment\nsplash.slide: Go at Google\ntutorial.slide: Get started with Go\nwaza.slide: Concurrency is not Parallelism\nzen.slide: Go and the Zen of Python\n2011 lex.slide: Lexical Scanning in Go 2010 ExpressivenessOfGo-2010\ngo_talk-20100112\ngo_talk-20100121\ngo_talk-20100323\ngofrontend-gcc-summit-2010\n2009 go_talk-20091030 "},{"href":"https://gophers-latam.github.io/posts/2021/06/conversi%C3%B3n-json-a-go/","title":"Conversi√≥n JSON a Go","body":" json to go Uno de los formatos de datos que se encuentra con mucha frecuencia en programaci√≥n, principalmente web, es JavaScript Object Notation (JSON).\nCuando se recibe datos en formato JSON de representaci√≥n, debe convertirse a un formato que sea f√°cil de manipular en el programa en Go. Hay algunas herramientas en l√≠nea que permiten convertir fuente JSON directamente en estructuras Go, aunque haciendo una simple b√∫squeda google.com/search?q=json+to+go se ve varidad de resultados, las destacadas o pioneras son:\nJSON-to-Go - mholt.github.io/json-to-go/\nTransform - transform.tools/json-to-go\nJson2Struct - json2struct.mervine.net/\nPor √∫ltimo como extensi√≥n de navegador para mejor accesibilidad existe json to go para Chrome.\n"},{"href":"https://gophers-latam.github.io/posts/2021/05/golang-implementaci%C3%B3n-del-almacenamiento-en-cach%C3%A9/","title":"Golang: Implementaci√≥n del almacenamiento en cach√©","body":" go cache El almacenamiento en cach√© de datos en una aplicaci√≥n web a veces es necesario para evitar solicitar datos est√°ticos de una base de datos o un servicio externo una y otra vez. Go no proporciona ning√∫n paquete integrado en la librer√≠a est√°ndar para almacenar en cach√© las respuestas, pero lo admite a trav√©s de paquetes externos creados por la comunidad.\nHay una serie de paquetes, como github.com/coocood/freecache,¬†github.com/patrickmn/go-cache, github.com/eko/gocache y github.com/etcd-io/etcd (gRPC) que pueden ayudar a implementar el almacenamiento en cach√©. Por parte de la comunidad de Gophers LATAM se busca crear algo relacionado: github.com/gophers-latam/GoKey\nPara este post se estar√° usando github.com/patrickmn/go-cache para implementar un ejemplo de uso.\nEjemplo: Primero crear un directorio para el c√≥digo fuente de prueba e inicializar un go module. [go mod init cache-example]\nLuego crear archivo .go, donde se har√° un cach√© por medio de la librer√≠a y se completar√° con datos sobre el arranque del servidor, de la siguiente manera:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/patrickmn/go-cache\u0026#34; ) const ( CONN_PORT = \u0026#34;8080\u0026#34; ) var newCache *cache.Cache func init() { newCache = cache.New(5*time.Minute, 10*time.Minute) newCache.Set(\u0026#34;gophers\u0026#34;, \u0026#34;gophers latam\u0026#34;, cache.DefaultExpiration) } func getFromCache(w http.ResponseWriter, r *http.Request) { gophers, found := newCache.Get(\u0026#34;gophers\u0026#34;) if found { log.Print(\u0026#34;Key encontrada en cach√© con valor, como : \u0026#34;, gophers.(string)) fmt.Fprintf(w, \u0026#34;Hola \u0026#34;+gophers.(string)) } else { log.Print(\u0026#34;Key no encontrada en cach√© : \u0026#34;, \u0026#34;gophers\u0026#34;) fmt.Fprintf(w, \u0026#34;Key no encontrada en cach√©\u0026#34;) } } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, getFromCache) err := http.ListenAndServe(\u0026#34;:\u0026#34;+CONN_PORT, nil) if err != nil { log.Fatal(\u0026#34;error al iniciar el servidor http : \u0026#34;, err) return } } Ejecutar el c√≥digo. Como funciona: Una vez iniciado, el servidor HTTP comenzar√° a escuchar localmente en el puerto 8080. Al inicio, la clave con el nombre gophers con un valor como gophers latam se agregar√° a la cach√©.\nAl navegar por http://localhost:8080/ se leer√° un valor de key de la cach√© y lo agregar√° a Hola como se muestra en la siguiente captura de pantalla:\nLog en terminal:\nSe ha especificado el tiempo de caducidad de los datos de la cach√© en el programa como 5 minutos, lo que significa que la clave que se ha creado en la cach√© al iniciar el servidor no estar√° all√≠ despu√©s de 5 minutos. Por lo tanto, acceder a la misma URL nuevamente despu√©s de 5 minutos devolver√° que la clave no es encontrada en la cach√© del servidor, de la siguiente manera:\nUsando var newCache *cache.Cache, se declara una cach√© privada.\nSe actualiza la funci√≥n init() donde se crea un cach√© con 5 minutos de tiempo de vencimiento y 10 minutos de intervalo de limpieza, y se agrega un elemento a cach√© con una clave como gophers con su valor como gophers latam y su valor de vencimiento como 0, lo que significa que se quiere usar el tiempo de vencimiento predeterminado de la cach√©.\nPara usarse se define el controlador getFromCache donde se recupera el valor de una clave en cach√©. Si se encuentra, se escribe en respuesta HTTP, de lo contrario, se escribe el mensaje Key no encontrada en cach√©.\n"},{"href":"https://gophers-latam.github.io/posts/2021/05/golang-init-func/","title":"Golang: Init func","body":" init func Cada programa en Go debe tener un paquete main con una funci√≥n main para ser ejecutado. Sin embargo, esto impone algunas limitaciones para determinadas soluciones, como las librer√≠as. Imagina que importamos una librer√≠a a nuestro c√≥digo.\nUna librer√≠a no est√° dise√±ada para ser ejecutada, ofrece estructuras de datos, m√©todos, funciones, etc. Es probable que las librer√≠as ni siquiera tengan un paquete main. Si esta librer√≠a requiere alguna configuraci√≥n inicial antes de ser invocada (inicializar variables, detectar el sistema operativo, etc.) parece imposible.\nGo define las funciones init que se ejecutan una vez por paquete. Cuando importamos un paquete, el tiempo de ejecuci√≥n (runtime) de Go sigue este orden:\nInicializar los paquetes importados de forma recursiva. Inicializar y asignar valores a las variables. Ejecutar las funciones de init. Ejemplos: 1. - En el resultado para el c√≥digo de ejemplo se muestra c√≥mo la inicializaci√≥n sigue el orden descrito anteriormente. La funci√≥n xSetter se invoca primero, seguida de init y la funci√≥n main.\npackage main import \u0026#34;fmt\u0026#34; var x = xSetter() func xSetter() int { fmt.Println(\u0026#34;xSetter\u0026#34;) return 42 } func init() { fmt.Println(\u0026#34;Init function\u0026#34;) } func main() { fmt.Println(\u0026#34;Este es el main\u0026#34;) } Salida en ejecuci√≥n: La funci√≥n init no tiene argumentos ni devuelve ning√∫n valor. Un paquete puede tener varias funciones init y no se pueden invocar desde ninguna parte del c√≥digo.\nGo no permite importar un paquete si no se usa dentro del c√≥digo. Sin embargo, es posible que solo nos interese ejecutar las funciones init de un paquete. Esto es lo que Go llama los efectos secundarios de un paquete (side effects pkg). Por lo general, esto se hace en paquetes que realizan alguna operaci√≥n de arranque o registro. La instrucci√≥n especial import _¬†solo llama a las funciones init de un paquete que no requiere su uso dentro del c√≥digo.\n2. - Ejemplo usando import _ :¬†importado el paquete \u0026ldquo;a\u0026rdquo; para utilizar sus efectos secundarios. Observar que este paquete tiene dos funciones init que se ejecutan antes del init del paquete de importaci√≥n. [go mod init ejemplo2]\nejemplo2/main.go\npackage main import ( \u0026#34;fmt\u0026#34; _ \u0026#34;ejemplo2/a\u0026#34; ) func init() { fmt.Println(\u0026#34;Init desde mi programa\u0026#34;) } func main() { fmt.Println(\u0026#34;Mi programa\u0026#34;) } ejemplo2/a/a.go\npackage a import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;Init 1 desde paquete a\u0026#34;) } func init() { fmt.Println(\u0026#34;Init 2 desde paquete a\u0026#34;) } Salida en ejecuci√≥n: "},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-referencia-esencial-go-modules/","title":"Golang: Referencia esencial Go modules","body":" Go Modules Esta es una hoja de trucos esenciales, no una referencia oficial. Con el fin de que sea conciso, se omitieron aspectos menos frecuentes, dado que este sitio desde su repositorio esta abierto a cambios de contribuidores en la comunidad de Gophers LATAM cualquiera puede hacer cambios que mejoren este contenido.\nInicio r√°pido Gesti√≥n de dependencias go get -d github.com/path/to/module # agregar o actualizar dep (-v log verboso) go get -d github.com/dep/two/v2@v2.1.0 # usar una versi√≥n espec√≠fica go get -d github.com/dep/commit@branch # usar una rama espec√≠fica go get -d -u ./... # actualizar m√≥dulos utilizados en subdirectorios go get -d github.com/dep/legacy@none # eliminar dep Comandos √∫tiles go mod tidy # organizar y limpiar go.mod and go.sum go mod download # descargar deps en cach√© de m√≥dulos go mod init github.com/path/to/module # inicializar nuevo m√≥dulo go mod why -m github.com/path/to/module # por qu√© el m√≥dulo es una dependencia? go install github.com/path/to/bin@latest # construir e instalar binario Anatom√≠a del go.mod // ruta de importaci√≥n de Go con lugar donde se aloja el m√≥dulo module github.com/my/library go 1.16 // versi√≥n utilizada para desarrollar m√≥dulo (usar nuevas funciones de lenguaje) require ( github.com/dep/one v1.0.0 // v2 y posteriores tienen versi√≥n principal en ruta del m√≥dulo github.com/dep/two/v2 v2.3.0 // \u0026#34;pseudo-versi√≥n\u0026#34; que se refiere a un commit y no a una versi√≥n etiquetada. github.com/dep/other v0.0.0-20180523231146-b3f5c0f6e5f1 github.com/dep/legacy v2.0.0+incompatible // \u0026#34;incompatible\u0026#34; significa que el paquete a√∫n no se ha migrado a nuevos m√≥dulos de Go ) exclude github.com/dep/legacy v1.9.2 // evitar que se use una versi√≥n de m√≥dulo espec√≠fica replace github.com/dep/one =\u0026gt; github.com/fork/one // reemplazar este m√≥dulo con este otro Selecci√≥n de versi√≥n m√≠nima (MVS) Para crear un programa, Go necesita saber exactamente qu√© dependencias necesita y qu√© versi√≥n usar.\nGo utiliza MVS como una forma sencilla y predecible de decidir qu√© versi√≥n utilizar.\nFunciona as√≠:\nEl m√≥dulo desde el que est√° ejecutando es el \u0026ldquo;m√≥dulo main\u0026rdquo;\nEncuentra todas las dependencias que necesita el m√≥dulo principal (de forma recursiva, usando los archivos go.mod de las dependencias)\nPara cada dependencia, usar la mayor versi√≥n que cualquier go.mod haya especificado expl√≠citamente\nEjemplo: En este ejemplo, el m√≥dulo principal depende de A 1.0 y B 2.1.\nDado que B 2.1 depende de A 1.1, esta es la versi√≥n de A que se utilizar√°.\nDado que se usa A 1.1, tambi√©n en C 1.1.\nLa lista final de dependencias es:\nA 1.1 B 2.1 C 1.1 Fuentes: Referencia oficial: https://golang.org/ref/mod\nVersi√≥n del post original: https://encore.dev/guide/go.mod\n"},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-la-interfaz-vac%C3%ADa/","title":"Golang: La interfaz vac√≠a","body":" Interface type Explicaci√≥n breve sobre el tipo interfaz vacia y nula.\nSe define una interfaz vac√≠a como interface{}, y puede contener un valor de cualquier tipo:\nvar i interface{} i = \u0026#34;hola gophers\u0026#34; fmt.Println(i) Si se necesita probar si una interfaz es de cierto tipo, se usa una aserci√≥n de tipo:\nvar i interface{} i = \u0026#34;hola gophers\u0026#34; s, ok := i.(string) if !ok { fmt.Println(\u0026#34;s is not type string\u0026#34;) } fmt.Println(s) En el ejemplo anterior, i es un tipo string, por lo que el segundo valor de retorno de la aserci√≥n de tipo es verdadero (ok) y s contiene el valor por debajo de este. Si hubiera sido de otro tipo, como un int, entonces el ok habr√≠a sido falso y s habr√≠a sido el valor cero del tipo que se estaba tratando de afirmar, es decir, 0.\nInterfaz nula Una interfaz en Go es esencialmente una tupla que contiene el tipo y el valor subyacentes. Para que una interfaz se considere nula, tanto el tipo como el valor deben ser nulos (nil). Ejemplo:\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { var i interface{} fmt.Println(i == nil) fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, i, i) var s *string fmt.Println(\u0026#34;s == nil:\u0026#34;, s == nil) i = s fmt.Println(\u0026#34;i == nil:\u0026#34;, i == nil) fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, i, i) Salida:\ntrue \u0026lt;nil\u0026gt;, \u0026lt;nil\u0026gt; s == nil: true i == nil: false *string, \u0026lt;nil\u0026gt; Observar que la variable s es nil, pero cuando se establece la interfaz i en s, se verifica si i es nil, i no se considera nil. Esto se debe a que la interfaz tiene un tipo concreto por debajo establecido y las interfaces solo son nulas cuando tanto el tipo concreto como el valor son nulos.\n"},{"href":"https://gophers-latam.github.io/search/","title":"B√∫squeda","body":""},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-mantener-actualizado-el-sdk/","title":"Golang: Mantener actualizado el SDK","body":" Update Go Como ocurre con todos los lenguajes de programaci√≥n, hay actualizaciones peri√≥dicas de las herramientas de desarrollo de Go. El SDK Go son binarios nativos que no dependen de un tiempo de ejecuci√≥n independiente, por lo que no hay que preocuparse de que la actualizaci√≥n del entorno de desarrollo pueda hacer que los programas actualmente implementados fallen. Puede tenerse programas compilados con diferentes versiones de Go ejecut√°ndose simult√°neamente en la misma computadora o m√°quina virtual.\nDesde Go 1.2, ha habido una nueva versi√≥n importante aproximadamente cada seis meses. Tambi√©n hay versiones menores con correcciones de errores y seguridad que se publican seg√∫n sea necesario. Dados los r√°pidos ciclos de desarrollo y el compromiso del equipo de Go con la compatibilidad con versiones anteriores, las versiones de Go tienden a ser incrementales en lugar de expansivas. La promesa de compatibilidad de Go es una descripci√≥n detallada de c√≥mo el equipo de Go planea evitar romper el c√≥digo de Go. Dice que no habr√° cambios retr√≥grados en el lenguaje o la librer√≠a est√°ndar para cualquier versi√≥n de Go que comience con 1, a menos que el cambio sea necesario para un error o correcci√≥n de seguridad. Sin embargo, puede haber (y ha habido) cambios incompatibles con versiones anteriores en los indicadores o la funcionalidad de los comandos go.\nA pesar de estas garant√≠as de compatibilidad con versiones anteriores, los errores ocurren, por lo que es natural querer asegurarse de que una nueva versi√≥n no rompa los programas personales ya hechos. Una opci√≥n es instalar un entorno Go secundario. Por ejemplo, si actualmente se est√° ejecutando la versi√≥n 1.15.2 y se quiere probar la versi√≥n 1.16.3, debe usarse los siguientes comandos:\ngo get golang.org/dl/go.1.16.3 go1.16.3 download Luego se puede usar el comando go1.16.3 en lugar del comando go para ver si la versi√≥n 1.16.3 funciona para los programas ya hechos anteriormente con la nueva versi√≥n de Go:\ngo1.16.3 build Una vez que se haya validado que el c√≥digo funciona, puede eliminarse el entorno secundario buscando el GOROOT, elimin√°ndolo y luego eliminando el binario del directorio $GOPATH/bin. A continuaci√≥n, las indicaciones de c√≥mo hacerlo en Mac OS, Linux y BSD respectivamente:\ngo1.16.3 env GOROOT /Users/gobook/sdk/go1.16.3 rm -rf $(go1.16.3 env GOROOT) rm $(go env GOPATH)/bin/go1.16.3 Cuando se est√° listo para actualizar las herramientas de desarrollo de Go instaladas en la computadora, los usuarios de Mac y Windows tienen la ruta m√°s f√°cil. Aquellos que instalaron con brew o chocolatey pueden usar esas herramientas para actualizar. Aquellos que usaron los instaladores en golang.org/dl pueden descargar el √∫ltimo instalador, que elimina la versi√≥n anterior cuando se instala la nueva.\nLos usuarios de Linux y BSD en general deben descargar la √∫ltima versi√≥n, mover la versi√≥n anterior a un directorio de respaldo, expandir la nueva versi√≥n y luego eliminar la versi√≥n anterior, algo as√≠:\nmv /usr/local/go /usr/local/old-go tar -C /usr/local -xzf go1.16.3.linux-amd64.tar.gz rm -rf /usr/local/old-go Como nota final, igual en cada versi√≥n que sale en el canal del Discord #üì∞fuente-noticias se comparte autom√°ticamente del canal de Twitter oficial como obtener la nueva versi√≥n.\n"},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-resumen-reglas/","title":"Golang: Resumen reglas","body":" Go Police El lenguaje de programaci√≥n Go fue creado para hacer el trabajo f√°cilmente.\nGo tiene conceptos similares a los lenguajes imperativos y el tipado est√°tico.\nTambi√©n es r√°pido en la compilaci√≥n, r√°pido de ejecutar e implementar. Grande y complejo.\nEn este post, se explican conceptos b√°sicos de Go tratando algunos conceptos o reglas importantes.\nLos principales temas tratados son los siguientes:\nEscribir comentarios. Librer√≠as e importaci√≥n. Funciones. Tipos de datos. Valores de retorno con nombre. Variables y memoria. Control de sentencias. Generar funciones. Ejecuci√≥n diferida. Interfaces. M√∫ltiples entradas. Manejo de errores. Ejecuci√≥n simult√°nea. Escribir comentarios: Para escribir un comentario de una l√≠nea\n// comentario de una sola l√≠nea Escribir un comentario con m√°s de una l√≠nea\n/* comentario de multi-l√≠nea */ Librer√≠as e importaci√≥n: Cada archivo de c√≥digo fuente comienza con la palabra clave package. La palabra clave main se utiliza para identificar el archivo como un archivo operativo, no como una librer√≠a.\npackage main Para importar un paquete de la librer√≠a est√°ndar, terceros o personal al archivo, usamos la instrucci√≥n import de la siguiente manera:\nimport ( \u0026#34;fmt\u0026#34; // paquete en la librer√≠a est√°ndar \u0026#34;io/ioutil\u0026#34; // se aplican funciones de E/S m \u0026#34;math\u0026#34; // usando la letra m para acortar o hacer alias del nombre de la librer√≠a de funciones matem√°ticas \u0026#34;net/http\u0026#34; // web server \u0026#34;os\u0026#34; // funciones a nivel del sistema operativo, como el manejo de archivos \u0026#34;strconv\u0026#34; // conversiones de texto ) Funciones: Las funciones se definen mediante la palabra func seguida del nombre de la funci√≥n.\nLa funci√≥n main es privada y es la entrada al archivo ejecutable del programa (Go usa llaves ornamentadas {} para definir partes / bloques).\nfunc main() { // salida de texto en la unidad main en stdout (salida estandar) con Println de fmt (stdlib pkg) fmt.Println (\u0026#34;Hello world!\u0026#34;) // llamar a una funci√≥n del paquete actual beyondHello() } Las funciones necesitan par√©ntesis que reciben par√°metros, e incluso en ausencia de par√°metros, se requieren par√©ntesis.\nfunc beyondHello() { // declaraci√≥n de variable (la variable debe declararse antes de usarse) var x int // dar valor a la variable x = 3 // definici√≥n corta usando := incluye definici√≥n de variable, especificando su tipo y d√°ndole valor y := 4 // una funci√≥n que devuelve dos valores separados sum, prod := learnMultiple (x, y) // imprimir salida de forma sencilla y directa fmt.Println (\u0026#34;sum:\u0026#34;, sum, \u0026#34;prod:\u0026#34;, prod) learnTypes() } La definici√≥n de funci√≥n puede tener m√∫ltiples coeficientes y valores de retorno. Por ejemplo, learnMultiple toma los coeficientes x, y \u0026hellip; y devuelve dos valores de sum y prod de tipo Int.\nfunc learnMultiple (x, y int) (sum, prod int) { // separar los valores devueltos con una coma regular return x + y, x * y } Tipos de datos: func learnTypes() { // las declaraciones cortas generalmente cumplen el prop√≥sito deseado // definir una variable de texto usando comillas dobles str := \u0026#34;Learn Go!\u0026#34; // definir una variable de texto con comillas simples s2 := `A \u0026#34;raw\u0026#34; string literal can include line breaks.` // definir variable tipo runa que es otro nombre para el tipo int32 que contiene unicode g := \u0026#39;Œ£\u0026#39; // float f := 3.14195 // definici√≥n de n√∫mero complejo (Complex) c := 3 + 4i // definir variables usando var var u uint = 7 // n√∫mero natural (entero positivo) var pi float32 = 22. / 7 // un decimal de 32 bits // definici√≥n corta byte (es otro nombre para uint8) n := byte (\u0026#39;\\n\u0026#39;) // arrays tienen un tama√±o fijo, y son fijos en momento de compilaci√≥n // definir un array int de 4 elementos con un valor inicial de cero var a4 [4] int // definir un array de 3 elementos con valores 3, 1 y 5 a3 := [...] int {3, 1, 5} Go ofrece un tipo de datos llamado Slices. Los Slices entendibles como \u0026ldquo;rebanadas\u0026rdquo;, \u0026ldquo;porciones\u0026rdquo;, \u0026ldquo;segmentos\u0026rdquo; tienen un tama√±o din√°mico. Las matrices (array) y los segmentos (slice) tienen ventajas, pero los casos de uso de los segmentos son m√°s comunes. La siguiente instrucci√≥n define un segmento de tipo int\n// observar la diferencia entre el array y la declaraci√≥n del slice, donde cuando // el slice est√° definido no hay un n√∫mero que determine su tama√±o s3: = [] int {4, 5, 9} // definir un tipo int con cuatro elementos con valores cero s4: = make ([] int, 4) // solo definir, y no hay selecci√≥n var d2 [] [] float64 // m√©todo para convertir el tipo de texto en slice bs: = [] byte (\u0026#34;a slice\u0026#34;) Por la naturaleza de los slice din√°micos, es posible agregar nuevos elementos usando la funci√≥n append incorporada. Primero se pasa el slice al que queremos agregar y luego los elementos que queremos agregar.\ns := [] int {1, 2, 3} s = append (s, 4, 5, 6) // se imprimir√° un slice con el siguiente contenido [1 2 3 4 5 6] fmt.Println (s) Para agregar un slice a otro slice, pasamos los dos slices en la funci√≥n en lugar de pasar elementos individuales, y siguiendo el segundo slice con tres puntos.\ns = append (s, [] int {7, 8, 9} ...) // se imprimir√° un slice con el siguiente contenido [1 2 3 4 5 6 7 8 9] fmt.Println (s) La siguiente instrucci√≥n define las variables p y q como punteros en dos variables de tipo int que contienen dos valores devueltos por la funci√≥n learnMemory:\np, q := learnMemory() // tema de reglas por ver Cuando un asterisco precede a un cursor, significa el valor de la variable a la que se refiere el cursor, como en el siguiente ejemplo los valores de las dos variables devueltas por la funci√≥n learnMemory:\nfmt.Println (*p, *q) Los mapas (maps) en Go son arrays din√°micos y modificables que son similares al tipo de diccionario o hash en otros lenguajes.\n// aqu√≠ un mapa cuya clave es tipo texto y los valores de los elementos num√©ricos. m: = map [string] int {\u0026#34;three\u0026#34;: 3, \u0026#34;four\u0026#34;: 4} m [\u0026#34;one\u0026#34;] = 1 Las variables no utilizadas son errores. El subrayado, guion bajo, operador blanco o Blank Identifier de la siguiente manera hace usar la variable pero ignora valores al mismo tiempo:\n_, _, _, _, _, _, _, _, _, _ = str, s2, g, f, u, pi, n, a3, s4, bs Valores de retorno con nombre: A diferencia de otros lenguajes, las funciones pueden tener valores de retorno con nombre. Donde el nombre se devuelve al valor de la funci√≥n en la l√≠nea de la definici√≥n de la funci√≥n, esta caracter√≠stica permite regresar f√°cilmente desde cualquier punto de la funci√≥n adem√°s del uso de la palabra return solo sin mencionar nada despu√©s:\nfunc learnNamedReturns (x, y int) (z int) { z = x * y // aqu√≠ impl√≠citamente significa devolver el valor de la variable z return } Nota: El lenguaje Go se basa en gran medida en la recolecci√≥n de basura. Go tiene indicadores pero no c√°lculos (puede confundir un cursor vac√≠o, pero no puede aumentar el cursor). Tener cuidado con valores de retorno de nil pointer reference.\nVariables y memoria: Las variables p y q a continuaci√≥n son indicadores del tipo int y representan valores de retorno en la funci√≥n. Cuando se define, los cursores est√°n vac√≠os; sin embargo, el uso de la funci√≥n incorporada new hace que el valor de la variable num√©rica p se refiera a cero, y por lo tanto ocupa espacio en la memoria; es decir, p ya no est√° vac√≠o.\nfunc learnMemory() (p, q* int) { p = new(int) // definir un slice de 20 elementos como una sola unidad en la memoria. s := make([] int, 20) // dar valor a un elemento s[3] = 7 // definir una nueva variable local a nivel de funci√≥n r := -2 // devolver dos valores de la funci√≥n, que son direcciones de memoria // para las variables s y r, respectivamente. return \u0026amp;s[3], \u0026amp;r } func expensiveComputation() float64 { return m.Exp (10) } Control de sentencias Las sentencias condicionales requieren corchetes ornamentados y no requieren par√©ntesis.\nfunc learnFlowControl() { if true {fmt.Println (\u0026#34;told ya\u0026#34; ) } if false { // Rusters. } else { // Gophers. } Usar la instrucci√≥n switch si se necesita escribir m√°s de una secuencia condicional.\nx := 42.0 switch x { case 0: case 1: case 42: case 43: default: } Como sentencia condicional, la cl√°usula for no toma par√©ntesis. Las variables definidas en la cl√°usula for son visibles a nivel de la sentencia.\nfor x: = 0; x \u0026lt;3; x ++ { fmt.Println (\u0026#34;iteration\u0026#34;, x) } La instrucci√≥n for es la √∫nica instrucci√≥n de iteraci√≥n en el lenguaje Go y tiene otra formas, de la siguiente manera:\n// repetici√≥n infinita for { // break para detener la repetici√≥n break // continue para ir a la siguiente iteraci√≥n continue } Se puede utilizar el range para pasar elementos de array, slice, text string, map, channel.\nEl range de canal (channel) devuelve un valor, y dos valores cuando se usa en slice, array, text string, o map.\n// ejemplo: for key, value := range map [string] int {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} { // imprimir el valor de cada elemento del mapa fmt.Printf (\u0026#34;key =% s, value =% d \\n\u0026#34;, key, value) } Usar el gui√≥n bajo (_) contra valor de retorno en la clave si solo se desea el valor, de la siguiente manera:\nfor _, name: = range [] string {\u0026#34;Bob\u0026#34;, \u0026#34;Bill\u0026#34;, \u0026#34;Joe\u0026#34;} { fmt.Printf (\u0026#34;Hello,% s \\n\u0026#34;, name) } Se puede usar la declaraci√≥n corta con la sentencia condicional para que se defina una variable y luego se verifique en la sentencia de condici√≥n.\nPor ejemplo se define una variable y, se le da un valor y luego se coloca la condici√≥n de la sentencia para que est√©n separadas por un punto y coma.\nif y := expensiveComputation(); y \u0026gt; x { x = y } Se puede definir funciones an√≥nimas falsas directamente en el c√≥digo.\nxBig := func() bool { // x:= 42 que fue declarada antes donde de menciona la sentencia switch return x \u0026gt; 10000 } x = 99999 // la funci√≥n xBig ahora devuelve el valor verdadero fmt.Println (\u0026#34;xBig:\u0026#34;, xBig()) x = 1.3e3 // Despu√©s de modificar el valor de x a 1.3e3 que es igual a 1300 (es decir, mayor que 1000) // la funci√≥n xBig devuelve falso fmt.Println (\u0026#34;xBig:\u0026#34;, xBig()) Adem√°s de lo anterior, es posible definir funci√≥n fantasma y llamarla en la misma l√≠nea y pasarla a otra funci√≥n siempre que se llame directamente y el tipo de resultado sea consistente con lo esperado en el par√°metro de la funci√≥n.\nfmt.Println (\u0026#34;Add + double two numbers:\u0026#34;, func (a, b int) int { return (a + b) * 2 } (10, 2)) goto love love: learnFunctionFactory() // Una funci√≥n que devuelve una funci√≥n learnDefer() // Dormir learnInterfaces() // Trabajar con interfaces } Generar funciones Se puede tratar las funciones como objetos separados. Por ejemplo, crear una funci√≥n y el valor de retorno es otra.\nfunc learnFunctionFactory() { Los dos m√©todos siguientes para imprimir la oraci√≥n son iguales, pero el segundo m√©todo es m√°s claro, m√°s legible y com√∫n.\nfmt.Println(sentenceFactory (\u0026#34;summer\u0026#34;) (\u0026#34;A beautiful\u0026#34;, \u0026#34;day!\u0026#34;)) d: = sentenceFactory (\u0026#34;summer\u0026#34;) fmt.Println(d (\u0026#34;A beautiful\u0026#34;, \u0026#34;day!\u0026#34;)) fmt.Println(d (\u0026#34;A lazy\u0026#34;, \u0026#34;afternoon!\u0026#34;)) } Los decoradores se encuentran en algunos lenguajes de programaci√≥n y en el mismo concepto en Go para que poder pasar datos a funciones.\nfunc sentenceFactory(mystring string) func(before, after string) string { return func(before, after string) string { return fmt.Sprintf (\u0026#34;%s %s %s\u0026#34;, before, mystring, after) } } Ejecuci√≥n diferida Se puede usar la funci√≥n defer en funciones para realizar una acci√≥n antes de devolver el valor o resolver la funcion, y si se escribe m√°s de una, el orden en ejecuci√≥n de estas acciones es la contraria, como en learnDefer:\nfunc learnDefer() (ok bool) { // instrucciones diferidas se ejecutan antes de que la funci√≥n devuelva el resultado. defer fmt.Println (\u0026#34;deferred statements execute in reverse (LIFO) order.\u0026#34;) defer fmt.Println (\u0026#34;\\nThis line is being printed first because\u0026#34;) // defer se utiliza normalmente para cerrar un archivo despu√©s de abrirlo. return true } Interfaces Como ejemplo se define una funci√≥n llamada Stringer que contiene una funci√≥n llamada String; luego se define una estructura de dos d√≠gitos de tipo int nombrados x y y.\ntype Stringer interface { String() string } type pair struct { x, y int } Aqu√≠ se define la funci√≥n String como un pair, convirti√©ndose en un pair para la implementaci√≥n de la interfaz Stringer. La variable p a continuaci√≥n se llama receptor (receiver). Observar c√≥mo se accede a los campos de estructura de pair utilizando el nombre de la estructura seguido de un punto y luego el nombre del campo.\nfunc(p pair) String() string { return fmt.Sprintf (\u0026#34;(%d, %d)\u0026#34;, p.x, p.y) } Los puntos y comas se utilizan para crear un elemento de estructura (struct). Se usa la definici√≥n corta en el siguiente ejemplo para crear una variable llamada p y especificar su tipo en la estructura de pair.\nfunc learnInterfaces() { p := pair{3, 4} // llamar funci√≥n String de pair fmt.Println(p.String()) // definir una variable como i del tipo Stringer interface previamente definida var i Stringer // esta igualdad es correcta, porque se aplica pair de Stringer i = p // se llama funci√≥n String de la variable i de tipo Stringer y se obtiene // el mismo resultado que antes fmt.Println(i.String()) // al pasar las variables anteriores directamente a las funciones de impresi√≥n y salida fmt, // estas funciones llaman a la funci√≥n String para imprimir la representaci√≥n de la variable. */ // Las siguientes dos l√≠neas dan el mismo resultado de impresi√≥n fmt.Println(p) fmt.Println(i) learnVariadicParams (\u0026#34;great\u0026#34;, \u0026#34;learning\u0026#34;, \u0026#34;here!\u0026#34;) } M√∫ltiples entradas Es posible pasar variedad de variables a funciones sin un n√∫mero definido de par√°metros.\nfunc learnVariadicParams (myStrings... interface{}) { // la siguiente iteraci√≥n recorre los elementos de entrada de datos de la funci√≥n. for _, param: = range myStrings { fmt.Println(\u0026#34;param:\u0026#34;, param) } // se pasa la entrada de la funci√≥n variadica como par√°metro de otra funci√≥n (para Sprintln) fmt.Println (\u0026#34;params:\u0026#34;, fmt.Sprintln(myStrings...)) learnErrorHandling() } Manejo de errores La palabra clave \u0026ldquo;ok\u0026rdquo; se utiliza para determinar si una sentencia es correcta. Si ocurre un error, se puede usar una variable err para conocer m√°s detalles sobre el error.\nfunc learnErrorHandling() { m := map [int] string{3: \u0026#34;three\u0026#34;, 4: \u0026#34;four\u0026#34;} if x, ok := m[1]; !ok { // ok aqu√≠ ser√° falso porque el n√∫mero 1 no est√° en el mapa m fmt.Println(\u0026#34;no one there\u0026#34;) } else { // x ser√° el valor en el mapa fmt.Print(x) } // aqui se intenta convertir valor de texto a n√∫mero que resultar√° en un error, // se imprimen los detalles del error si err no es nil */ if _, err := strconv.Atoi(\u0026#34;non-int\u0026#34;); err != nil { fmt.Println(err) } learnConcurrency() } Ejecuci√≥n simult√°nea Usando una funci√≥n anterior para hacer una suma num√©rica a algunos n√∫meros en conjunto. Se usa make para crear una variable sin especificar un valor para ella.\nfunc learnConcurrency() { // se crea una variable de tipo canal llamada c c := make(chan int) // creando tres funciones Go concurrentes. Los n√∫meros se incrementar√°n simult√°neamente // (en paralelo si el dispositivo est√° configurado para hacerlo). // todas las transmisiones ir√°n al mismo canal // \u0026#34;go\u0026#34; aqu√≠ significa iniciar una nueva funci√≥n go inc(0, c) go inc(10, c) go inc(-805, c) // luego hacer tres lecturas desde el mismo canal e imprimir los resultados. // no hay un orden de acceso de lectura desde el canal, y // tambi√©n cuando el canal aparece a la derecha de la operaci√≥n // \u0026lt;- significa que esta leyendo y recibiendo del canal fmt.Println(\u0026lt;-c, \u0026lt;-c, \u0026lt;-c) // nuevo canal con texto cs := make(chan string) // canal contiene canales de texto ccs := make(chan chan string) // enviar valor 84 al canal c go func() {c \u0026lt;- 84}() // enviar palabra al canal cs go func() {cs \u0026lt;- \u0026#34;wordy\u0026#34;}() // instrucci√≥n select es similar a la instrucci√≥n switch, // pero en cada caso contiene un proceso para un canal que // est√° listo para comunicarse. select { // valor recibido del canal se puede guardar en una variable case i := \u0026lt;-c: fmt.Printf(\u0026#34;it\u0026#39;s a %T\u0026#34;, i) case \u0026lt;-cs: fmt.Println(\u0026#34;it\u0026#39;s a string\u0026#34;) // canal vac√≠o pero listo para comunicarse case \u0026lt;-ccs: fmt.Println(\u0026#34;didn\u0026#39;t happen.\u0026#34;) } } "},{"href":"https://gophers-latam.github.io/opensource/","title":"Open Source","body":"Software Open Source compartido en GitHub por Gophers LATAM.\n"},{"href":"https://gophers-latam.github.io/contacto/","title":"Contacto","body":"Medios de contacto con Gophers LATAM.\n"},{"href":"https://gophers-latam.github.io/colaboradores/","title":"Colaboradores","body":"Miembros p√∫blicos en github.com/gophers-latam\n"},{"href":"https://gophers-latam.github.io/biografia/","title":"Biograf√≠a","body":"Gophers LATAM es un esfuerzo conjunto por hacer una comunidad de programadores Golang en Espa√±ol-Latino.\nLos inicios son desde el canal de YouTube de Tom√°s Lingotti, luego se adopto la idea del Discord el cual ha sido impulsado desde el mismo canal y en otros canales de YouTube, tales como el de Golandia. Compartido en otros medios como Facebook, Twitter y Linkedin. Y con apoyo desde los inicios de zeroidentidad.\nOtra forma en la que se ha adoptado hacer presencia es en Github.\n\u0026ndash; Todo lo mencionado surgi√≥ desde octubre del 2020.\n"},{"href":"https://gophers-latam.github.io/proyectos/awesomelatam/","title":"Awesome Latam","body":"Colecci√≥n de contenidos y recursos principalmente en Espa√±ol para desarrolladores de Golang\n"},{"href":"https://gophers-latam.github.io/proyectos/go-tour/","title":"Go Tour","body":"Para aquellos que a√∫n no lo conocen, el \u0026lsquo;Tour de Go\u0026rsquo; representa una introducci√≥n excepcional al lenguaje de programaci√≥n Go. Ofrece ejemplos interactivos y explicaciones detalladas, convirti√©ndose en una herramienta invaluable para aquellos que desean aprender Go.\nComo comunidad, hemos realizado la traducci√≥n del sitio, permitiendo que cualquier persona de habla hispana tenga acceso a esta valiosa herramienta de aprendizaje.\nEstatus: Pendiente de aprobaci√≥n por el sitio oficial de Go (https://go-review.googlesource.com/c/website/+/545855).\n"},{"href":"https://gophers-latam.github.io/proyectos/gokey/","title":"GoKey","body":"GoKey es un cache en memoria. El principal aspecto es guardar, leer y borrar entradas dentro del ciclo de vida de la goroutine main. Es decir, si deja de correr, los datos se pierden.\nEstatus: ETAPA 1 - libreria cliente\n"},{"href":"https://gophers-latam.github.io/proyectos/gopherbot/","title":"Gopher-Bot","body":"Bot de discord como mascota y utilidad de comandos en server discord.me/gophers-latam.\nEl bot se encuentra inactivo debido a que kintohub ya dejo de dar servicio. "}]}