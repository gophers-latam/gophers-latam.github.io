{"results":[{"href":"https://gophers-latam.github.io/search/","title":"B煤squeda","body":""},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-mantener-actualizado-el-sdk/","title":"Golang: Mantener actualizado el SDK","body":" Update Go  Como ocurre con todos los lenguajes de programaci贸n, hay actualizaciones peri贸dicas de las herramientas de desarrollo de Go. El SDK Go son binarios nativos que no dependen de un tiempo de ejecuci贸n independiente, por lo que no hay que preocuparse de que la actualizaci贸n del entorno de desarrollo pueda hacer que los programas actualmente implementados fallen. Puede tenerse programas compilados con diferentes versiones de Go ejecut谩ndose simult谩neamente en la misma computadora o m谩quina virtual.\nDesde Go 1.2, ha habido una nueva versi贸n importante aproximadamente cada seis meses. Tambi茅n hay versiones menores con correcciones de errores y seguridad que se publican seg煤n sea necesario. Dados los r谩pidos ciclos de desarrollo y el compromiso del equipo de Go con la compatibilidad con versiones anteriores, las versiones de Go tienden a ser incrementales en lugar de expansivas. La promesa de compatibilidad de Go es una descripci贸n detallada de c贸mo el equipo de Go planea evitar romper el c贸digo de Go. Dice que no habr谩 cambios retr贸grados en el lenguaje o la librer铆a est谩ndar para cualquier versi贸n de Go que comience con 1, a menos que el cambio sea necesario para un error o correcci贸n de seguridad. Sin embargo, puede haber (y ha habido) cambios incompatibles con versiones anteriores en los indicadores o la funcionalidad de los comandos go.\nA pesar de estas garant铆as de compatibilidad con versiones anteriores, los errores ocurren, por lo que es natural querer asegurarse de que una nueva versi贸n no rompa los programas personales ya hechos. Una opci贸n es instalar un entorno Go secundario. Por ejemplo, si actualmente se est谩 ejecutando la versi贸n 1.15.2 y se quiere probar la versi贸n 1.16.3, debe usarse los siguientes comandos:\ngo get golang.org/dl/go.1.16.3 go1.16.3 download Luego se puede usar el comando go1.16.3 en lugar del comando go para ver si la versi贸n 1.16.3 funciona para los programas ya hechos anteriormente con la nueva versi贸n de Go:\ngo1.16.3 build Una vez que se haya validado que el c贸digo funciona, puede eliminarse el entorno secundario buscando el GOROOT, elimin谩ndolo y luego eliminando el binario del directorio $GOPATH/bin. A continuaci贸n, las indicaciones de c贸mo hacerlo en Mac OS, Linux y BSD respectivamente:\ngo1.16.3 env GOROOT /Users/gobook/sdk/go1.16.3 rm -rf $(go1.16.3 env GOROOT) rm $(go env GOPATH)/bin/go1.16.3 Cuando se est谩 listo para actualizar las herramientas de desarrollo de Go instaladas en la computadora, los usuarios de Mac y Windows tienen la ruta m谩s f谩cil. Aquellos que instalaron con brew o chocolatey pueden usar esas herramientas para actualizar. Aquellos que usaron los instaladores en golang.org/dl pueden descargar el 煤ltimo instalador, que elimina la versi贸n anterior cuando se instala la nueva.\nLos usuarios de Linux y BSD en general deben descargar la 煤ltima versi贸n, mover la versi贸n anterior a un directorio de respaldo, expandir la nueva versi贸n y luego eliminar la versi贸n anterior, algo as铆:\nmv /usr/local/go /usr/local/old-go tar -C /usr/local -xzf go1.16.3.linux-amd64.tar.gz rm -rf /usr/local/old-go Como nota final, igual en cada versi贸n que sale en el canal del Discord #fuente-noticias se comparte autom谩ticamente del canal de Twitter oficial como obtener la nueva versi贸n.\n"},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-resumen-reglas/","title":"Golang: Resumen reglas","body":" Go Police  El lenguaje de programaci贸n Go fue creado para hacer el trabajo f谩cilmente.\nGo tiene conceptos similares a los lenguajes imperativos y el tipado est谩tico. Tambi茅n es r谩pido en la compilaci贸n, r谩pido de ejecutar e implementar. Grande y complejo.\nEn este post, se explican conceptos b谩sicos de Go tratando algunos conceptos o reglas importantes.\nLos principales temas tratados son los siguientes:\n Escribir comentarios. Librer铆as e importaci贸n. Funciones. Tipos de datos. Valores de retorno con nombre. Variables y memoria. Control de sentencias. Generar funciones. Ejecuci贸n diferida. Interfaces. M煤ltiples entradas. Manejo de errores. Ejecuci贸n simult谩nea.  Escribir comentarios: Para escribir un comentario de una l铆nea\n// comentario de una sola l铆nea Escribir un comentario con m谩s de una l铆nea\n/* comentario de multi-l铆nea */ Librer铆as e importaci贸n: Cada archivo de c贸digo fuente comienza con la palabra clave package. La palabra clave main se utiliza para identificar el archivo como un archivo operativo, no como una librer铆a.\npackage main Para importar un paquete de la librer铆a est谩ndar, terceros o personal al archivo, usamos la instrucci贸n import de la siguiente manera:\nimport ( \u0026#34;fmt\u0026#34; // paquete en la librer铆a est谩ndar  \u0026#34;io/ioutil\u0026#34; // se aplican funciones de E/S  m \u0026#34;math\u0026#34; // usando la letra m para acortar o hacer alias del nombre de la librer铆a de funciones matem谩ticas  \u0026#34;net/http\u0026#34; // web server  \u0026#34;os\u0026#34; // funciones a nivel del sistema operativo, como el manejo de archivos  \u0026#34;strconv\u0026#34; // conversiones de texto ) Funciones: Las funciones se definen mediante la palabra func seguida del nombre de la funci贸n.\nLa funci贸n main es privada y es la entrada al archivo ejecutable del programa (Go usa llaves ornamentadas {} para definir partes / bloques).\nfunc main() { // salida de texto en la unidad main en stdout (salida estandar) con Println de fmt (stdlib pkg)  fmt.Println (\u0026#34;Hello world!\u0026#34;) // llamar a una funci贸n del paquete actual  beyondHello() } Las funciones necesitan par茅ntesis que reciben par谩metros, e incluso en ausencia de par谩metros, se requieren par茅ntesis.\nfunc beyondHello() { // declaraci贸n de variable (la variable debe declararse antes de usarse)  var x int // dar valor a la variable  x = 3 // definici贸n corta usando := incluye definici贸n de variable, especificando su tipo y d谩ndole valor  y := 4 // una funci贸n que devuelve dos valores separados  sum, prod := learnMultiple (x, y) // imprimir salida de forma sencilla y directa  fmt.Println (\u0026#34;sum:\u0026#34;, sum, \u0026#34;prod:\u0026#34;, prod) learnTypes() } La definici贸n de funci贸n puede tener m煤ltiples coeficientes y valores de retorno. Por ejemplo, learnMultiple toma los coeficientes x, y \u0026hellip; y devuelve dos valores de sum y prod de tipo Int.\nfunc learnMultiple (x, y int) (sum, prod int) { // separar los valores devueltos con una coma regular return x + y, x * y } Tipos de datos: func learnTypes() { // las declaraciones cortas generalmente cumplen el prop贸sito deseado  // definir una variable de texto usando comillas dobles  str := \u0026#34;Learn Go!\u0026#34; // definir una variable de texto con comillas simples  s2 := `A \u0026#34;raw\u0026#34; string literal can include line breaks.` // definir variable tipo runa que es otro nombre para el tipo int32 que contiene unicode  g := \u0026#39;危\u0026#39; // float  f := 3.14195 // definici贸n de n煤mero complejo (Complex)  c := 3 + 4i // definir variables usando var  var u uint = 7 // n煤mero natural (entero positivo)  var pi float32 = 22. / 7 // un decimal de 32 bits  // definici贸n corta byte (es otro nombre para uint8)  n := byte (\u0026#39;\\n\u0026#39;) // arrays tienen un tama帽o fijo, y son fijos en momento de compilaci贸n  // definir un array int de 4 elementos con un valor inicial de cero  var a4 [4] int // definir un array de 3 elementos con valores 3, 1 y 5  a3 := [...] int {3, 1, 5} Go ofrece un tipo de datos llamado Slices. Los Slices entendibles como \u0026ldquo;rebanadas\u0026rdquo;, \u0026ldquo;porciones\u0026rdquo;, \u0026ldquo;segmentos\u0026rdquo; tienen un tama帽o din谩mico. Las matrices (array) y los segmentos (slice) tienen ventajas, pero los casos de uso de los segmentos son m谩s comunes. La siguiente instrucci贸n define un segmento de tipo int\n// observar la diferencia entre el array y la declaraci贸n del slice, donde cuando  // el slice est谩 definido no hay un n煤mero que determine su tama帽o  s3: = [] int {4, 5, 9} // definir un tipo int con cuatro elementos con valores cero  s4: = make ([] int, 4) // solo definir, y no hay selecci贸n  var d2 [] [] float64 // m茅todo para convertir el tipo de texto en slice  bs: = [] byte (\u0026#34;a slice\u0026#34;) Por la naturaleza de los slice din谩micos, es posible agregar nuevos elementos usando la funci贸n append incorporada. Primero se pasa el slice al que queremos agregar y luego los elementos que queremos agregar.\ns := [] int {1, 2, 3} s = append (s, 4, 5, 6) // se imprimir谩 un slice con el siguiente contenido [1 2 3 4 5 6]  fmt.Println (s) Para agregar un slice a otro slice, pasamos los dos slices en la funci贸n en lugar de pasar elementos individuales, y siguiendo el segundo slice con tres puntos.\ns = append (s, [] int {7, 8, 9} ...) // se imprimir谩 un slice con el siguiente contenido [1 2 3 4 5 6 7 8 9]  fmt.Println (s) La siguiente instrucci贸n define las variables p y q como punteros en dos variables de tipo int que contienen dos valores devueltos por la funci贸n learnMemory:\np, q := learnMemory() // tema de reglas por ver Cuando un asterisco precede a un cursor, significa el valor de la variable a la que se refiere el cursor, como en el siguiente ejemplo los valores de las dos variables devueltas por la funci贸n learnMemory:\nfmt.Println (*p, *q) Los mapas (maps) en Go son arrays din谩micos y modificables que son similares al tipo de diccionario o hash en otros lenguajes.\n// aqu铆 un mapa cuya clave es tipo texto y los valores de los elementos num茅ricos.  m: = map [string] int {\u0026#34;three\u0026#34;: 3, \u0026#34;four\u0026#34;: 4} m [\u0026#34;one\u0026#34;] = 1 Las variables no utilizadas son errores. El subrayado, guion bajo, operador blanco o Blank Identifier de la siguiente manera hace usar la variable pero ignora valores al mismo tiempo:\n_, _, _, _, _, _, _, _, _, _ = str, s2, g, f, u, pi, n, a3, s4, bs Valores de retorno con nombre: A diferencia de otros lenguajes, las funciones pueden tener valores de retorno con nombre. Donde el nombre se devuelve al valor de la funci贸n en la l铆nea de la definici贸n de la funci贸n, esta caracter铆stica permite regresar f谩cilmente desde cualquier punto de la funci贸n adem谩s del uso de la palabra return solo sin mencionar nada despu茅s:\nfunc learnNamedReturns (x, y int) (z int) { z = x * y // aqu铆 impl铆citamente significa devolver el valor de la variable z  return } Nota: El lenguaje Go se basa en gran medida en la recolecci贸n de basura. Go tiene indicadores pero no c谩lculos (puede confundir un cursor vac铆o, pero no puede aumentar el cursor). Tener cuidado con valores de retorno de nil pointer reference.\nVariables y memoria: Las variables p y q a continuaci贸n son indicadores del tipo int y representan valores de retorno en la funci贸n. Cuando se define, los cursores est谩n vac铆os; sin embargo, el uso de la funci贸n incorporada new hace que el valor de la variable num茅rica p se refiera a cero, y por lo tanto ocupa espacio en la memoria; es decir, p ya no est谩 vac铆o.\nfunc learnMemory() (p, q* int) { p = new(int) // definir un slice de 20 elementos como una sola unidad en la memoria.  s := make([] int, 20) // dar valor a un elemento  s[3] = 7 // definir una nueva variable local a nivel de funci贸n  r := -2 // devolver dos valores de la funci贸n, que son direcciones de memoria  // para las variables s y r, respectivamente.  return \u0026amp;s[3], \u0026amp;r } func expensiveComputation() float64 { return m.Exp (10) } Control de sentencias Las sentencias condicionales requieren corchetes ornamentados y no requieren par茅ntesis.\nfunc learnFlowControl() { if true {fmt.Println (\u0026#34;told ya\u0026#34; ) } if false { // Rusters. } else { // Gophers. } Usar la instrucci贸n switch si se necesita escribir m谩s de una secuencia condicional.\nx := 42.0 switch x { case 0: case 1: case 42: case 43: default: } Como sentencia condicional, la cl谩usula for no toma par茅ntesis. Las variables definidas en la cl谩usula for son visibles a nivel de la sentencia.\nfor x: = 0; x \u0026lt;3; x ++ { fmt.Println (\u0026#34;iteration\u0026#34;, x) } La instrucci贸n for es la 煤nica instrucci贸n de iteraci贸n en el lenguaje Go y tiene otra formas, de la siguiente manera:\n// repetici贸n infinita for { // break para detener la repetici贸n  break // continue para ir a la siguiente iteraci贸n  continue } Se puede utilizar el range para pasar elementos de array, slice, text string, map, channel.\nEl range de canal (channel) devuelve un valor, y dos valores cuando se usa en slice, array, text string, o map.\n// ejemplo: for key, value := range map [string] int {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} { // imprimir el valor de cada elemento del mapa  fmt.Printf (\u0026#34;key =% s, value =% d \\n\u0026#34;, key, value) } Usar el gui贸n bajo (_) contra valor de retorno en la clave si solo se desea el valor, de la siguiente manera:\nfor _, name: = range [] string {\u0026#34;Bob\u0026#34;, \u0026#34;Bill\u0026#34;, \u0026#34;Joe\u0026#34;} { fmt.Printf (\u0026#34;Hello,% s \\n\u0026#34;, name) } Se puede usar la declaraci贸n corta con la sentencia condicional para que se defina una variable y luego se verifique en la sentencia de condici贸n.\nPor ejemplo se define una variable y, se le da un valor y luego se coloca la condici贸n de la sentencia para que est茅n separadas por un punto y coma.\nif y := expensiveComputation(); y \u0026gt; x { x = y } Se puede definir funciones an贸nimas falsas directamente en el c贸digo.\nxBig := func() bool { // x:= 42 que fue declarada antes donde de menciona la sentencia switch  return x \u0026gt; 10000 } x = 99999 // la funci贸n xBig ahora devuelve el valor verdadero  fmt.Println (\u0026#34;xBig:\u0026#34;, xBig()) x = 1.3e3 // Despu茅s de modificar el valor de x a 1.3e3 que es igual a 1300 (es decir, mayor que 1000)  // la funci贸n xBig devuelve falso  fmt.Println (\u0026#34;xBig:\u0026#34;, xBig()) Adem谩s de lo anterior, es posible definir funci贸n fantasma y llamarla en la misma l铆nea y pasarla a otra funci贸n siempre que se llame directamente y el tipo de resultado sea consistente con lo esperado en el par谩metro de la funci贸n.\nfmt.Println (\u0026#34;Add + double two numbers:\u0026#34;, func (a, b int) int { return (a + b) * 2 } (10, 2)) goto love love: learnFunctionFactory() // Una funci贸n que devuelve una funci贸n  learnDefer() // Dormir  learnInterfaces() // Trabajar con interfaces } Generar funciones Se puede tratar las funciones como objetos separados. Por ejemplo, crear una funci贸n y el valor de retorno es otra.\nfunc learnFunctionFactory() { Los dos m茅todos siguientes para imprimir la oraci贸n son iguales, pero el segundo m茅todo es m谩s claro, m谩s legible y com煤n.\nfmt.Println(sentenceFactory (\u0026#34;summer\u0026#34;) (\u0026#34;A beautiful\u0026#34;, \u0026#34;day!\u0026#34;)) d: = sentenceFactory (\u0026#34;summer\u0026#34;) fmt.Println(d (\u0026#34;A beautiful\u0026#34;, \u0026#34;day!\u0026#34;)) fmt.Println(d (\u0026#34;A lazy\u0026#34;, \u0026#34;afternoon!\u0026#34;)) } Los decoradores se encuentran en algunos lenguajes de programaci贸n y en el mismo concepto en Go para que poder pasar datos a funciones.\nfunc sentenceFactory(mystring string) func(before, after string) string { return func(before, after string) string { return fmt.Sprintf (\u0026#34;%s %s %s\u0026#34;, before, mystring, after) } } Ejecuci贸n diferida Se puede usar la funci贸n defer en funciones para realizar una acci贸n antes de devolver el valor o resolver la funcion, y si se escribe m谩s de una, el orden en ejecuci贸n de estas acciones es la contraria, como en learnDefer:\nfunc learnDefer() (ok bool) { // instrucciones diferidas se ejecutan antes de que la funci贸n devuelva el resultado.  defer fmt.Println (\u0026#34;deferred statements execute in reverse (LIFO) order.\u0026#34;) defer fmt.Println (\u0026#34;\\nThis line is being printed first because\u0026#34;) // defer se utiliza normalmente para cerrar un archivo despu茅s de abrirlo.  return true } Interfaces Como ejemplo se define una funci贸n llamada Stringer que contiene una funci贸n llamada String; luego se define una estructura de dos d铆gitos de tipo int nombrados x y y.\ntype Stringer interface { String() string } type pair struct { x, y int } Aqu铆 se define la funci贸n String como un pair, convirti茅ndose en un pair para la implementaci贸n de la interfaz Stringer. La variable p a continuaci贸n se llama receptor (receiver). Observar c贸mo se accede a los campos de estructura de pair utilizando el nombre de la estructura seguido de un punto y luego el nombre del campo.\nfunc(p pair) String() string { return fmt.Sprintf (\u0026#34;(%d, %d)\u0026#34;, p.x, p.y) } Los puntos y comas se utilizan para crear un elemento de estructura (struct). Se usa la definici贸n corta en el siguiente ejemplo para crear una variable llamada p y especificar su tipo en la estructura de pair.\nfunc learnInterfaces() { p := pair{3, 4} // llamar funci贸n String de pair  fmt.Println(p.String()) // definir una variable como i del tipo Stringer interface previamente definida  var i Stringer // esta igualdad es correcta, porque se aplica pair de Stringer  i = p // se llama funci贸n String de la variable i de tipo Stringer y se obtiene  // el mismo resultado que antes  fmt.Println(i.String()) // al pasar las variables anteriores directamente a las funciones de impresi贸n y salida fmt,  // estas funciones llaman a la funci贸n String para imprimir la representaci贸n de la variable. */  // Las siguientes dos l铆neas dan el mismo resultado de impresi贸n  fmt.Println(p) fmt.Println(i) learnVariadicParams (\u0026#34;great\u0026#34;, \u0026#34;learning\u0026#34;, \u0026#34;here!\u0026#34;) } M煤ltiples entradas Es posible pasar variedad de variables a funciones sin un n煤mero definido de par谩metros.\nfunc learnVariadicParams (myStrings... interface{}) { // la siguiente iteraci贸n recorre los elementos de entrada de datos de la funci贸n.  for _, param: = range myStrings { fmt.Println(\u0026#34;param:\u0026#34;, param) } // se pasa la entrada de la funci贸n variadica como par谩metro de otra funci贸n (para Sprintln)  fmt.Println (\u0026#34;params:\u0026#34;, fmt.Sprintln(myStrings...)) learnErrorHandling() } Manejo de errores La palabra clave \u0026ldquo;ok\u0026rdquo; se utiliza para determinar si una sentencia es correcta. Si ocurre un error, se puede usar una variable err para conocer m谩s detalles sobre el error.\nfunc learnErrorHandling() { m := map [int] string{3: \u0026#34;three\u0026#34;, 4: \u0026#34;four\u0026#34;} if x, ok := m[1]; !ok { // ok aqu铆 ser谩 falso porque el n煤mero 1 no est谩 en el mapa m  fmt.Println(\u0026#34;no one there\u0026#34;) } else { // x ser谩 el valor en el mapa  fmt.Print(x) } // aqui se intenta convertir valor de texto a n煤mero que resultar谩 en un error,  // se imprimen los detalles del error si err no es nil */  if _, err := strconv.Atoi(\u0026#34;non-int\u0026#34;); err != nil { fmt.Println(err) } learnConcurrency() } Ejecuci贸n simult谩nea Usando una funci贸n anterior para hacer una suma num茅rica a algunos n煤meros en conjunto. Se usa make para crear una variable sin especificar un valor para ella.\nfunc learnConcurrency() { // se crea una variable de tipo canal llamada c  c := make(chan int) // creando tres funciones Go concurrentes. Los n煤meros se incrementar谩n simult谩neamente  // (en paralelo si el dispositivo est谩 configurado para hacerlo).  // todas las transmisiones ir谩n al mismo canal  // \u0026#34;go\u0026#34; aqu铆 significa iniciar una nueva funci贸n  go inc(0, c) go inc(10, c) go inc(-805, c) // luego hacer tres lecturas desde el mismo canal e imprimir los resultados.  // no hay un orden de acceso de lectura desde el canal, y  // tambi茅n cuando el canal aparece a la derecha de la operaci贸n  // \u0026lt;- significa que esta leyendo y recibiendo del canal  fmt.Println(\u0026lt;-c, \u0026lt;-c, \u0026lt;-c) // nuevo canal con texto  cs := make(chan string) // canal contiene canales de texto  ccs := make(chan chan string) // enviar valor 84 al canal c  go func() {c \u0026lt;- 84}() // enviar palabra al canal cs  go func() {cs \u0026lt;- \u0026#34;wordy\u0026#34;}() // instrucci贸n select es similar a la instrucci贸n switch,  // pero en cada caso contiene un proceso para un canal que  // est谩 listo para comunicarse.  select { // valor recibido del canal se puede guardar en una variable  case i := \u0026lt;-c: fmt.Printf(\u0026#34;it\u0026#39;s a %T\u0026#34;, i) case \u0026lt;-cs: fmt.Println(\u0026#34;it\u0026#39;s a string\u0026#34;) // canal vac铆o pero listo para comunicarse  case \u0026lt;-ccs: fmt.Println(\u0026#34;didn\u0026#39;t happen.\u0026#34;) } } "},{"href":"https://gophers-latam.github.io/opensource/","title":"Open Source","body":"Software Open Source en GitHub por Gophers LATAM.\n"},{"href":"https://gophers-latam.github.io/contacto/","title":"Contacto","body":"Medios de contacto con Gophers LATAM.\n"},{"href":"https://gophers-latam.github.io/colaboradores/","title":"Colaboradores","body":"Miembros p煤blicos en github.com/gophers-latam\n"},{"href":"https://gophers-latam.github.io/acerca/","title":"Acerca","body":"Gophers LATAM es un esfuerzo conjunto por hacer una comunidad de programadores Golang en Espa帽ol-Latino.\nLos inicios son desde el canal YouTube de Tom谩s Lingotti luego se adopto la idea del Discord el cual ha sido impulsado desde el mismo canal y en otros canales tal como el de Golandia y en otros medios como Facebook, Twitter y Linkedin. Como tambien desde blog de ZeroIdentidad.\nOtra forma en la que se esta adoptando hacer presencia es en Github.\n\u0026ndash; Todo lo mencionado anteriormente data desde oto帽o del 2020.\n"},{"href":"https://gophers-latam.github.io/proyectos/awesomelatam/","title":"Awesome Latam","body":"Colecci贸n de contenidos y recursos principalmente en Espa帽ol para desarrolladores de Golang\n"},{"href":"https://gophers-latam.github.io/proyectos/gopherbot/","title":"Gopher-Bot","body":"Bot de discord como mascota y utilidad de comandos en server discord.io/go-latam.\n El bot se encuentra inactivo debido a que kintohub ya dejo de dar servicio.  "}]}