<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="ZeroIdentidad"><meta name=description content="Gophers LATAM"><meta property="og:image" content="https://gophers-latam.github.io//logo.png"><title>Simplificaciones en creación de Go – Gophers LATAM</title><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.d014c13d6e77ff98797c23bcfd3bdeaf0cb513a7bd8e559468cc442576c24a0e.css><link rel=stylesheet href=/css/syntax.min.f1fef9cbbfe9d2935981821d59853e89db60d137f9117a1279371320195f1d1a.css><link href='https://fonts.googleapis.com/css2?family=Work+Sans' rel=stylesheet type=text/css></head><body><div class=container><header class="page-header app-width"><div class=header-left><a href=/><img alt="Gophers LATAM" src=/img/gopher.png style=height:90px></a></div><div class=header-center><nav><a href=/>Inicio</a>
<a href=/biografia>Biografía</a>
<a href=/proyectos>Proyectos</a>
<a href=/posts>Posts</a>
<a href=/colaboradores>Colaboradores</a>
<a href=/contacto>Contacto</a></nav></div><div class=header-right><a class=button-search href=/search><img alt=Búsqueda src=/img/search.png></a></div></header><main class=app-width><article class=post><header><h2>Simplificaciones en creación de Go</h2><span class=tags><a class=tag href=/tags/basis>basis</a>
<a class=tag href=/tags/golang>golang</a></span>
<span class=meta><label>Por: <b>zeroidentidad</b></label>
<label>Publicado <b>May 5, 2024</b></label>
<label>Tiempo de lectura: <b>7 minutos</b>.</label></span></header><section class=body><figure class=post-figure><a href=/posts/2024/05/simplificaciones-en-creaci%C3%B3n-de-go/images/gophers.jpg><img src=/posts/2024/05/simplificaciones-en-creaci%C3%B3n-de-go/images/gophers_huc6926b7463e76b74736598b659c033b9_35704_1024x0_resize_q75_box.jpg width=1024 height=408 alt=" The Go Gopher https://go.dev/blog/gopher/header.jpg"></a><figcaption>The Go Gopher https://go.dev/blog/gopher/header.jpg</figcaption></figure><p>Para apostar todo por la expresividad del lenguaje entiéndase como hacer más fácil o comprensiva la lectura y escritura, en la creación de Go se establecieron simplificaciones fundamentales bajo la premisa &ldquo;Less can be more&rdquo;.</p><ul><li>Nota: en el transcurso de los años alguno que otro punto puede variar o haber derivado en otros cambios.</li></ul><ol><li><p><strong>Regular syntax (don&rsquo;t need a symbol table to parse):</strong> [Sintaxis regular (no necesita una tabla de símbolos para analizar)] Se refiere a una sintaxis de lenguaje de programación que es predecible y coherente, lo que facilita el análisis del código sin necesidad de una tabla de símbolos compleja.</p></li><li><p><strong>Garbage collection (only):</strong> [Recolección de basura (solamente)] Es un proceso automático en el que el sistema de ejecución de un lenguaje de programación gestiona automáticamente la memoria liberando objetos que ya no son necesarios.</p></li><li><p><strong>No header files:</strong> [No hay archivos de encabezado] En algunos lenguajes de programación, como C y C++, los archivos de encabezado (.h) se utilizan para declarar funciones, tipos y variables que se comparten entre varios archivos fuente (.c o .cpp). En Go, no se utilizan archivos de encabezado.</p></li><li><p><strong>Explicit dependencies:</strong> [Dependencias explícitas] Se refiere a tener que especificar claramente las dependencias que un módulo de software tiene con otros módulos, en lugar de depender de importaciones implícitas o automáticas.</p></li><li><p><strong>No circular dependencies:</strong> [No hay dependencias circulares] Se refiere a una restricción en la cual dos o más módulos dependen uno del otro de manera circular, lo cual puede causar problemas de compilación y diseño de software.</p></li><li><p><strong>Constants are just numbers:</strong> [Las constantes son solo números] En Go, las constantes pueden ser cualquier tipo de valor constante, no solo números, pero aquí se hace referencia específicamente a que las constantes pueden ser valores numéricos.</p></li><li><p><strong>Int and int32 are distinct types:</strong> [Int y int32 son tipos distintos] En Go, int y int32 son tipos de datos distintos. Aunque int es una palabra clave para un tipo de entero de tamaño variable en función de la arquitectura, int32 es específicamente un tipo de entero de 32 bits.</p></li><li><p><strong>Letter case sets visibility:</strong> [El caso definido de las letras establece la visibilidad] En Go, los nombres de variables, funciones y tipos que comienzan con una letra mayúscula son visibles fuera de su paquete (exportados), mientras que los nombres que comienzan con una letra minúscula son privados y solo visibles dentro del paquete.</p></li><li><p><strong>Methods for any type (no classes):</strong> [Métodos para cualquier tipo (no clases)] En Go, puedes definir métodos en cualquier tipo de datos, no solo en clases o estructuras. Esto se hace utilizando receptores.</p></li><li><p><strong>No subtype inheritance (no subclasses):</strong> [No hay herencia de subtipo (no hay subclases)] En Go, no hay concepto de clases ni herencia de subclases como en lenguajes orientados a objetos tradicionales. En su lugar, se utilizan interfaces para lograr polimorfismo.</p></li><li><p><strong>Package-level initialization and well-defined order of initialization:</strong> [Inicialización a nivel de paquete y orden de inicialización bien definido] En Go, las variables globales en un paquete pueden ser inicializadas con valores constantes o mediante funciones de inicialización definidas en el mismo paquete. La inicialización se realiza en un orden específico.</p></li><li><p><strong>Files compiled together in a package:</strong> [Archivos compilados juntos en un paquete] En Go, todos los archivos fuente de un paquete se compilan juntos en un solo paquete. No hay archivos de encabezado ni una separación física entre la declaración y la definición de las funciones y tipos.</p></li><li><p><strong>Package-level globals presented in any order:</strong> [Variables globales a nivel de paquete presentadas en cualquier orden] Las variables globales en un paquete de Go pueden ser declaradas y definidas en cualquier orden dentro del archivo fuente del paquete.</p></li><li><p><strong>No arithmetic conversions (constants help):</strong> [No hay conversiones aritméticas (las constantes ayudan)] En Go, las conversiones automáticas entre tipos numéricos no se realizan implícitamente, lo que ayuda a evitar errores y promueve una mayor precisión.</p></li><li><p><strong>Interfaces are implicit (no &ldquo;implements&rdquo; declaration):</strong> [Las interfaces son implícitas (no hay declaración de &ldquo;implements&rdquo;)] En Go, no necesitas declarar explícitamente que una estructura o tipo implementa una interfaz. Si una estructura implementa todos los métodos de una interfaz, se considera que implementa automáticamente esa interfaz.</p></li><li><p><strong>Embedding (no promotion to superclass):</strong> [Incorporación (sin promoción a superclase)] En Go, puedes embeber un tipo de estructura dentro de otro, lo que permite la composición de objetos. Sin embargo, no hay promoción automática de métodos como en algunos otros lenguajes orientados a objetos.</p></li><li><p><strong>Methods are declared as functions (no special location):</strong> [Los métodos se declaran como funciones (sin ubicación especial)] En Go, los métodos se declaran dentro del cuerpo del paquete, junto con otras funciones.</p></li><li><p><strong>Methods are just functions:</strong> [Los métodos son solo funciones] En Go, los métodos son simplemente funciones que toman un receptor como su primer argumento.</p></li><li><p><strong>Interfaces are just methods (no data):</strong> [Las interfaces son solo métodos (no datos)] En Go, las interfaces se componen solo de una lista de métodos que los tipos que las implementan deben proporcionar.</p></li><li><p><strong>Methods match by name only (not by type):</strong> [Los métodos coinciden solo por nombre (no por tipo)] En Go, dos métodos diferentes en dos tipos diferentes pueden tener el mismo nombre sin conflicto, siempre y cuando se apliquen a tipos diferentes.</p></li><li><p><strong>No constructors or destructors:</strong> [No hay constructores ni destructores] En Go, no hay métodos especiales para la inicialización o destrucción de objetos, como en algunos lenguajes orientados a objetos. En su lugar, se utilizan funciones de inicialización y limpieza según sea necesario.</p></li><li><p><strong>Postincrement and postdecrement are statements, not expressions:</strong> [El postincremento y el postdecremento son declaraciones, no expresiones] En Go, los operadores de postincremento (i++) y postdecremento (i&ndash;) se consideran declaraciones independientes y no pueden usarse como parte de expresiones más grandes.</p></li><li><p><strong>No preincrement or predecrement:</strong> [No hay preincremento ni predecremento] En Go, los operadores de preincremento (++i) y predecremento (&ndash;i) no están disponibles.</p></li><li><p><strong>Assignment is not an expression:</strong> [La asignación no es una expresión] En Go, la asignación de variables no devuelve un valor, por lo que no se puede utilizar como parte de una expresión más grande. Por ejemplo, x = y no devuelve ningún valor.</p></li><li><p><strong>Evaluation order defined in assignment, function call (no &ldquo;sequence point&rdquo;):</strong> [Orden de evaluación definido en la asignación, llamada de función (sin &ldquo;punto de secuencia&rdquo;)] Se refiere al hecho de que en Go, el orden en el que se evalúan las expresiones dentro de una asignación o llamada de función está bien definido y no hay un &ldquo;punto de secuencia&rdquo; como en otros lenguajes donde el comportamiento puede ser ambiguo.</p></li><li><p><strong>No pointer arithmetic:</strong> [No hay aritmética de punteros] En Go, no se permite realizar operaciones aritméticas directamente en punteros, como en lenguajes como C o C++.</p></li><li><p><strong>Memory is always zeroed:</strong> [La memoria siempre está inicializada a cero] En Go, la memoria asignada se inicializa siempre con cero, lo que significa que las variables y estructuras de datos se inicializan automáticamente a sus valores cero por defecto.</p></li><li><p><strong>Legal to take address of local variable:</strong> [Legal tomar la dirección de una variable local] En Go, es perfectamente válido tomar la dirección de una variable local y pasarla a funciones o devolverla como un valor, sin preocuparse por el tiempo de vida de la variable.</p></li><li><p><strong>No &ldquo;this&rdquo; in methods:</strong> [No hay &ldquo;this&rdquo; en métodos] A diferencia de otros lenguajes orientados a objetos, en Go no hay una palabra clave &ldquo;this&rdquo; para referirse al receptor en los métodos. En su lugar, se utiliza el nombre del receptor como el primer parámetro de los métodos.</p></li><li><p><strong>Segmented stacks:</strong> [Pilas segmentadas] Go utiliza pilas segmentadas para manejar la memoria de forma eficiente, lo que permite una mejor gestión del espacio de la pila en situaciones de concurrencia y recursión profunda.</p></li><li><p><strong>No const or other type annotations:</strong> [No hay &ldquo;const&rdquo; u otras anotaciones de tipo] En Go, no hay una palabra clave &ldquo;const&rdquo; que sea como en otros lenguajes de programación. Además, las anotaciones de tipo no son necesarias ya que el compilador puede inferir el tipo de manera automática.</p></li><li><p><strong>No templates:</strong> [No hay plantillas] A diferencia de algunos lenguajes como C++ que tienen plantillas, Go no proporciona un mecanismo de plantillas para la generación de código genérico.</p></li><li><p><strong>No exceptions:</strong> [No hay excepciones] Go no utiliza excepciones como mecanismo para manejar errores excepcionales. En su lugar, se prefieren los valores de retorno de error explícitos.</p></li><li><p><strong>Builtin string, slice, map:</strong> [String, slice y map incorporados] En Go, los tipos string, slice y map son tipos de datos incorporados en el lenguaje y proporcionan funcionalidad para manejar cadenas, listas dinámicas y mapas respectivamente.</p></li><li><p><strong>Array bounds checking:</strong> [Comprobación de límites de array] En Go, se realizan comprobaciones de límites de array en tiempo de ejecución para asegurar que no se acceda a índices fuera del rango válido del array, lo que ayuda a prevenir errores de segmentación y otros problemas relacionados con el acceso fuera de los límites del array.</p></li></ol><ul><li>Fuente de referencia: <a href=https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html>https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html</a></li></ul></section><section class=related><h3>Relacionados</h3><div class=post-list><article class="box box-post"><a class=title href=/posts/2024/04/explorando-frameworks-en-go-una-gu%C3%ADa-para-principiantes/><h3>Explorando Frameworks en Go: Una Guía para Principiantes</h3></a><time class=date>April
12
2024</time><div class=summary-container><figure class=post-figure><a href=/posts/2024/04/explorando-frameworks-en-go-una-gu%C3%ADa-para-principiantes/images/go-frameworks.png><img src=/posts/2024/04/explorando-frameworks-en-go-una-gu%C3%ADa-para-principiantes/images/go-frameworks_hu9ed9cb27069741b0ea452de8869c0657_86705_1024x0_resize_box_3.png width=1024 height=626 alt="go frameworks"></a><figcaption>go frameworks</figcaption></figure><p>Últimamente, en nuestro canal de <a href=https://discord.me/gophers-latam>discord</a>, hemos recibido numerosas preguntas, especialmente de aquellos que están dando sus primeros pasos con Go, sobre qué frameworks deberían considerar al comenzar a desarrollar con este lenguaje.
En este post, vamos a explorar temas como la biblioteca estándar, los diferentes frameworks disponibles en Go, sus opciones, cuáles son los más rápidos y los más utilizados.</p></div></article><article class="box box-post"><a class=title href=/posts/2024/02/codelab.-implementemos-un-worker-pool/><h3>CodeLab. Implementemos un Worker Pool</h3></a><time class=date>February
6
2024</time><div class=summary-container><figure class=post-figure><a href=/posts/2024/02/codelab.-implementemos-un-worker-pool/images/pools.png><img src=/posts/2024/02/codelab.-implementemos-un-worker-pool/images/pools_hu25c2df14317a6a74ebc7cc77c76ece4a_666661_1024x0_resize_box_3.png width=1024 height=794 alt=" Mengniu Dairy production line. Gentileza de  Peter Tittenberger y flickr. https://www.flickr.com/photos/ext504/3639675762/in/photostream/"></a><figcaption>Mengniu Dairy production line. Gentileza de Peter Tittenberger y flickr. https://www.flickr.com/photos/ext504/3639675762/in/photostream/</figcaption></figure><p>La concurrencia es una herramienta que nos ayuda a ejecutar tareas pesadas o que bloquean el avance de un proceso, mientras otras tareas se ejecutan, mejorando el rendimiento general.</p><p>Pero ¿Podemos hacer uso de la concurrencia sin ponernos un límite?</p></div></article><article class="box box-post"><a class=title href=/posts/2024/01/concatenando-strings.-construyendo-sql/><h3>Concatenando strings. Construyendo SQL</h3></a><time class=date>January
21
2024</time><div class=summary-container><figure class=post-figure><a href=/posts/2024/01/concatenando-strings.-construyendo-sql/images/builders.png><img src=/posts/2024/01/concatenando-strings.-construyendo-sql/images/builders_hu484691413f27fc3340745a7b2cb74546_371474_1024x0_resize_box_3.png width=1024 height=693 alt="json to go"></a><figcaption>json to go</figcaption></figure><p>Los strings son un tipo de dato peculiar. A simple vista parecieran no esconder nada raro, pero si los comparamos con tipos de dato numéricos encontramos diferencias interesantes.</p></div></article><article class="box box-post"><a class=title href=/posts/2024/01/desarrollo-con-go-en-neovim/><h3>Desarrollo con Go en Neovim</h3></a><time class=date>January
3
2024</time><div class=summary-container><figure class=post-figure><a href=/posts/2024/01/desarrollo-con-go-en-neovim/images/nvim-go.png><img src=/posts/2024/01/desarrollo-con-go-en-neovim/images/nvim-go_hu5d8b93b2e980550baa9318235e855019_465465_1024x0_resize_box_3.png width=1024 height=683 alt="Go con Neovim"></a><figcaption>Go con Neovim</figcaption></figure><p>En este post vamos a ver cómo configurar desde cero Neovim y específicamente cómo personalizarlo para que nuestro desarrollo con Go sea altamente productivo.</p></div></article><article class="box box-post"><a class=title href=/posts/2023/10/el-tour-de-go-ahora-en-espa%C3%B1ol/><h3>El tour de Go ahora en Español</h3></a><time class=date>October
27
2023</time><div class=summary-container><figure class=post-figure><a href=/posts/2023/10/el-tour-de-go-ahora-en-espa%C3%B1ol/images/tour3.png><img src=/posts/2023/10/el-tour-de-go-ahora-en-espa%C3%B1ol/images/tour3_hu513b247d847e7fe7c11df40df90a15e1_538565_1024x0_resize_box_3.png width=1024 height=1039 alt="Tour de Go en Español"></a><figcaption>Tour de Go en Español</figcaption></figure><p>¡Logramos algo increíble como comunidad!
La traducción del tour de Go al español.
Estamos emocionados de compartir con todos ustedes el increíble logro que hemos alcanzado juntos: la completa traducción del tour de Go al español.</p><p>Este proyecto fue un esfuerzo colaborativo en el que nuestra comunidad contribuyó con su tiempo y conocimiento para hacer que esta herramienta esté disponible para toda la comunidad hispanohablante. ¡El resultado es asombroso!</p></div></article></div></section><section class=comments><h3>Comentar</h3><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//gophers-latam.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></article></main><footer><a href=https://gohugo.io><img src=/img/hugo-logo.svg width=90 height=21></a>
<small>© 2024, Gophers LATAM. - Theme by <a href=https://github.com/zeroidentidad>zeroidentidad</a>.</small></footer></div></body></html>