<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="ZeroIdentidad"><meta name=description content="Gophers LATAM"><meta property="og:image" content="https://gophers-latam.github.io//logo.png"><title>Manejo de memoria 101. Memoria virtual, Stack y Heap – Gophers LATAM</title><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.ab5c854c8ff7113091eab0cdceefb34dd122f8b602777f88b8e6367f6ac3e7b2.css><link rel=stylesheet href=/css/syntax.min.f1fef9cbbfe9d2935981821d59853e89db60d137f9117a1279371320195f1d1a.css><link href='https://fonts.googleapis.com/css2?family=Work+Sans' rel=stylesheet type=text/css></head><body><div class=container><header class="page-header app-width"><div class=header-left><a href=/><img alt="Gophers LATAM" src=/img/gopher.png style=height:90px></a></div><div class=header-center><div class=menu-button><span><img alt="mobile menu" src=/img/menu.svg alt></span></div><nav class="nav-links hide-on-mobile"><a href=/>Inicio</a>
<a href=/biografia>Biografía</a>
<a href=/proyectos>Proyectos</a>
<a href=/posts>Posts</a>
<a href=/colaboradores>Colaboradores</a>
<a href=/contacto>Contacto</a></nav><script src=https://gophers-latam.github.io/js/header-mobile.js defer></script></div><div class=header-right><a class=button-search href=/search><img alt=Búsqueda src=/img/search.png></a></div></header><main class=app-width><article class=post><header><h2>Manejo de memoria 101. Memoria virtual, Stack y Heap</h2><span class=tags><a class=tag href=/tags/memoria>memoria</a>
<a class=tag href=/tags/aprendizaje>aprendizaje</a></span>
<span class=meta><label>Por: <b>Andrés Reyes, el Programador Pobre</b></label>
<label>Publicado <b>December 30, 2023</b></label>
<label>Tiempo de lectura: <b>9 minutos</b>.</label></span></header><section class=body><figure class=post-figure><a href=/posts/2023/12/manejo-de-memoria-101.-memoria-virtual-stack-y-heap/images/puzzle.jpg><img src=/posts/2023/12/manejo-de-memoria-101.-memoria-virtual-stack-y-heap/images/puzzle_hu8be483b27e2fd6a4219dea81ea7f0a7b_19838_1024x0_resize_q75_box.jpg width=1024 height=439 alt="Puzzle. imagen de dominio público gentileza piqsels. https://www.piqsels.com/en/public-domain-photo-smyfi"></a><figcaption>Puzzle. imagen de dominio público gentileza piqsels. https://www.piqsels.com/en/public-domain-photo-smyfi</figcaption></figure><p>Que Go tiene un recolector de basura integrado lo hemos escuchado muchas veces. Significa que no tenemos que preocuparnos de liberar la memoria que nuestra aplicación usa, pero ¿Deberiamos entender el ciclo de uso de memoria de nuestras aplicaciones? ¿El recolector de basura nos da derecho a olvidar y usar y abusar de ese recurso?</p><p>Y, primero que nada ¿Que diablos es la memoria de la que tanto se habla?</p><hr><h2 id=renuncia-de-responsabilidades-no-es-trivial-entender-la-forma-en-que-los-computadores-trabajan-en-aras-de-poder-difundir-intentaremos-simplificar-lo-mas-posible-en-ocasiones-mas-alla-de-lo-recomendado>Renuncia de responsabilidades. No es trivial entender la forma en que los computadores trabajan. En aras de poder difundir intentaremos simplificar lo mas posible, en ocasiones, mas alla de lo recomendado.</h2><p>Muchos programadores hemos llegado a Go desde lenguajes de tipado débil, donde hemos tendido a mirar recursos como la memoria como si fueran gratuitos. Nada mas lejos de la verdad, como dice el viejo dicho <a href=https://es.wikipedia.org/wiki/TANSTAAFL>No hay tal cosa como un almuerzo gratis</a> y si queremos convertirnos en programadores mínimamente competentes debemos tener al menos una idea básica sobre la forma en que se manejan dichos recursos. He ahí la razón de este artículo.</p><h2 id=memoria-virtual>Memoria virtual</h2><p>Aquellos que ya tengan la escritura de algunos programas a su haber saben que cuando declaramos una variable, lo que estamos haciendo es asignar un identificador a una dirección de memoria en la que guardaremos datos (si nunca ha declarado una variable, hagase un favor y vaya al <a href=https://go.dev/tour/basics/8>tour de go</a>).</p><p>Mas o menos cuando hablamos de memoria todos pensamos en una grilla homogenea, con direcciones para acceder a cada casilla comodamente.</p><p><img src=images/memgrid.png alt=memory></p><p>Pues bien, esa dirección de memoria no salió del aire por generación espontanea, existe físicamente de alguna forma en alguna parte.</p><p>En realidad, lo que llamamos memoria es una <strong>abstracción</strong> proporcionada por el sistema operativo, la cual oculta diferentes medios de almacenamiento.</p><ul><li><p><a href=https://es.wikipedia.org/wiki/Registro_(hardware)>Los registros del procesador</a></p></li><li><p><a href=https://es.wikipedia.org/wiki/Cach%C3%A9_de_CPU>La caché del procesador</a></p></li><li><p>RAM</p></li><li><p>Archivos en disco</p></li><li><p>Etc.</p></li></ul><p>En terminos generales, no sabemos en cual de estos medios de almacenamiento quedará almacenada nuestra variable. Solo sabemos que le hemos pedido memoria al sistema y que este nos la presentó adecuadamente para lograr nuestro objetivo. Claro, en aras de la eficiencia hay una gran probabilidad de que nuestro dato haya quedado guardado en RAM.</p><p>Esta <em>abstracción</em> a la que hicimos referencia, es lo que llamamos <strong>memoria virtual</strong>, es administrada por el sistema operativo y <em>es un recurso</em> el cual debe ser solicitado.</p><hr><h2 id=memoria-virtual-es-una-abstracción-que-provee-a-cada-proceso-la-ilusión-de-que-tiene-uso-exclusivo-sobre-la-memoria-principal>Memoria virtual es una abstracción que provee a cada proceso la ilusión de que tiene uso exclusivo sobre la memoria principal.</h2><p><em>Bryant, R. E. & O’Hallaron, D. R. (2016). Computer System: A Programmer’s Perspective (Third global edition). Pearson Education Limited.</em></p><p>La organización en forma de <em>Celdas de memoria</em> que nos es tan familiar es propia de la memoria virtual y como se imagina para que pueda funcionar se necesita una sofisticada interacción entre el sistema operativo y el hardware. Esta interacción se basa en un <em>mapeo</em>, <em>direccionamiento</em> o <em>traslación</em> entre las direcciones de la memoria virtual y el medio físico donde realmente se encuentre nuestro dato.</p><p>Cuando se ejecuta un programa, este tiene una visión uniforme de la memoria, la que llamamos <em>Espacio de direcciones virtual</em>, y dentro de este espacio hay dos áreas bien definidas que nos son de vital importancia.</p><h2 id=stack-y-heap>Stack y Heap</h2><h3 id=stack>Stack</h3><p>El Stack es una región de la memoria que es <em>localizada</em> para cada hilo de ejecución de nuestros programas. En el contexto de Go, decimos que cada gorutina tiene su propio Stack. Su objetivo es contener variables locales, argumentos y valores de retorno de funciones, etc.</p><p>Cuando se invoca una función, se agrega una nueva capa en el Stack y cuando la función termina, esa capa se quita a su vez del Stack.</p><hr><h2 id=llamamos-localizaciónallocation-al-proceso-de-reservar-memoria-para-almacenar-nuestros-datos-y-deslocalizacióndeallocation-al-proceso-de-liberarla-una-vez-que-ya-no-la-necesitamos>Llamamos <em>Localización/Allocation</em> al proceso de reservar memoria para almacenar nuestros datos, y <em>Deslocalización/Deallocation</em> al proceso de liberarla una vez que ya no la necesitamos.</h2><p>El Stack tiene la ventaja de que permite acceder rápidamente a la memoria, ¡claro! porque los datos más recientes están siempre en la capa superior. Además, como cuando una función termina su ejecución, su capa asociada en el Stack se quita, ¡La memoria utilizada para los datos en esa capa se ve <em>automáticamente deslocalizada</em>!</p><p>El Stack empieza con espacio pre-localizado de un tamaño fijo, si el runtime detecta que se está quedando sin espacio, localiza más y como la memoría está localizada de antemano, guardar datos en el Stack es barato y automático.</p><p><a href=https://github.com/golang/go/blob/master/src/runtime/stack.go#L75><img src=images/stack_go.png alt="Alt text"></a></p><p>Para que una variable sea asignada en el Stack, deben cumplirse una serie de requisitos:</p><ul><li><p>Tamaño fijo, conocido en tiempo de compilación</p></li><li><p>El runtime de Go debe ser capaz de determinar completamente su ciclo de vida</p></li><li><p>Su tamaño no debe superar la capacidad máxima del Stack (mas las salvaguardas del runtime)</p></li></ul><hr><h2 id=el-stack-es-rápido-localizar-y-dealocalizar-en-el-es-barato>El Stack es rápido, localizar y dealocalizar en el es barato.</h2><p>Si estas y otras condiciones no son cumplidas, la variable escapará al Heap.</p><h3 id=heap>Heap</h3><p>El Heap es el área del espacio de direcciones virtual que el runtime de Go solicita para almacenar los datos al ejecutar nuestro programa. El Heap crece dinámicamente y su objetivo es contener los datos que necesitamos persistan mas allá del tiempo de vida de una función o que son muy grandes para ser alojados en el stack.</p><p>El que nuestros datos <em>escapen</em> al Heap es costoso porque implica una <em>localización</em>, lo que significa que:</p><p>1 Se verifica que el Heap tenga suficiente capacidad para el valor que almacenaremos en el.</p><p>2 Si el punto 1 no se cumple, se debe solicitar más memoria al sistema operativo para el Heap. Se produce una <a href=https://www.man7.org/linux/man-pages/man2/syscalls.2.html>System Call</a> solicitando el recurso. En el mundo real este paso se realiza independientemente. El runtime monitorea constantemente el Heap y algunos algoritmos implementan un una <em>meta</em>, un límite de memoria, que una vez alcanzado o sobrepasado produce la solicitud de mas recursos al sistema operatvo.</p><p>3 Se localiza la memoria en el Heap (por simplicidad incluyamos en este apartado la escritura de los datos que guardaremos).</p><p>4 Se almacena en el Stack un puntero a la dirección de memoria inicial de la localización en el Heap.</p><hr><h2 id=el-heap-es-flexible-pero-la-flexibilidad-viene-con-un-costo>El Heap es flexible, pero la flexibilidad viene con un costo</h2><p>¡Todo esto es bastante trabajo para guardar un monton de datos! ¡Sea parsimonioso! Si, porque localizar en el Heap, si bien proporciona muchas ventajas, tiene un costo. Es por eso que en el ecosistema de Go usted encontrará librerías que se jactan de tener cero localizaciones, es decir, estan escritas tan cuidadosamente que no guardan datos en el Heap, sólo usan el Stack.</p><h2 id=escapando-al-heap>Escapando al Heap</h2><p>Revisemos el siguiente código</p><p><em>main.go</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>retString</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>retVal</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;achu&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>retVal</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Hemos definido una función que devuelve un string. Construyamos un benchmark para que la podamos analizar.</p><p><em>main_test.go</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Benchmark_retString</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>ResetTimer</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>retString</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>StopTimer</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Log</span>(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>StartTimer</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Al ejecutar el benchmark veremos algo parecido al siguiente reporte</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go test -bench . -benchmem                  
</span></span><span style=display:flex><span>goos: linux
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: exmem
</span></span><span style=display:flex><span>cpu: Intel<span style=color:#f92672>(</span>R<span style=color:#f92672>)</span> Core<span style=color:#f92672>(</span>TM<span style=color:#f92672>)</span> i7-10700 CPU @ 2.90GHz
</span></span><span style=display:flex><span>Benchmark_retString-16          <span style=color:#ae81ff>1000000000</span>               0.3356 ns/op          <span style=color:#ae81ff>0</span> B/op          <span style=color:#ae81ff>0</span> allocs/op
</span></span></code></pre></div><p>Donde el benchmark nos informa con <code>0 allocs/op</code> que han ocurrido 0 localizaciones al heap.</p><p>Reunamos más información. Agreguemos al comando el flag <code>-gcflags "-m -m"</code> que hará que el compilador realice un <em>análisis de escape</em>, el cual nos informará de movimientos de datos al heap.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go test -gcflags <span style=color:#e6db74>&#34;-m&#34;</span> -bench . -benchmem  
</span></span><span style=display:flex><span><span style=color:#75715e># exmem [exmem.test]</span>
</span></span><span style=display:flex><span>./main.go:3:6: can inline retString
</span></span><span style=display:flex><span>./main_test.go:13:16: inlining call to retString
</span></span><span style=display:flex><span>./main_test.go:7:26: leaking param: b
</span></span><span style=display:flex><span>./main_test.go:17:7: ... argument does not escape
</span></span><span style=display:flex><span>./main_test.go:17:8: a escapes to heap
</span></span><span style=display:flex><span><span style=color:#75715e># exmem.test</span>
</span></span><span style=display:flex><span>_testmain.go:37:6: can inline init.0
</span></span><span style=display:flex><span>_testmain.go:45:24: inlining call to testing.MainStart
</span></span><span style=display:flex><span>_testmain.go:45:42: testdeps.TestDeps<span style=color:#f92672>{}</span> escapes to heap
</span></span><span style=display:flex><span>_testmain.go:45:24: &amp;testing.M<span style=color:#f92672>{</span>...<span style=color:#f92672>}</span> escapes to heap
</span></span><span style=display:flex><span>goos: linux
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: exmem
</span></span><span style=display:flex><span>cpu: Intel<span style=color:#f92672>(</span>R<span style=color:#f92672>)</span> Core<span style=color:#f92672>(</span>TM<span style=color:#f92672>)</span> i7-10700 CPU @ 2.90GHz
</span></span><span style=display:flex><span>Benchmark_retString-16          <span style=color:#ae81ff>1000000000</span>               0.3356 ns/op          <span style=color:#ae81ff>0</span> B/op          <span style=color:#ae81ff>0</span> allocs/op
</span></span></code></pre></div><p>Continua reportandonos 0 localizaciones, pero ha agregado información interesante. Observe la siguiente línea en el reporte:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./main_test.go:17:8: a escapes to heap
</span></span></code></pre></div><p>Nos indica que la variable <code>a</code> escapa al Heap ¡Y nos dice el lugar exacto donde este escape ocurre!</p><p><img src=images/escape1.png alt="Alt text"></p><p>La línea 17 de nuestro archivo de benchmark, precisamente donde pasamos la variable al logger.</p><p>Esto demuestra que el escape no es producto de nuestro código pues el log de la variable está ahí solo como medio informativo y no es parte del mismo.</p><p>Construyamos otra función, esta vez una que devuelva un puntero a una variable local.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rePointerToString</span>() <span style=color:#f92672>*</span><span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>retVal</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;achu&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>retVal</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Y agreguemos el benchmark correspondiente.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Benchmark_retPointerToString</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>ResetTimer</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>rePointerToString</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>StopTimer</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Log</span>(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>StartTimer</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Al ejecutar el benchmark veremos un reporte parecido a lo que sigue:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>goos: linux
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: exmem
</span></span><span style=display:flex><span>cpu: Intel<span style=color:#f92672>(</span>R<span style=color:#f92672>)</span> Core<span style=color:#f92672>(</span>TM<span style=color:#f92672>)</span> i7-10700 CPU @ 2.90GHz
</span></span><span style=display:flex><span>Benchmark_retPointerToString
</span></span><span style=display:flex><span>Benchmark_retPointerToString-16    	50917658	        24.86 ns/op	      <span style=color:#ae81ff>16</span> B/op	       <span style=color:#ae81ff>1</span> allocs/op
</span></span><span style=display:flex><span>PASS
</span></span><span style=display:flex><span>ok  	exmem	1.292s
</span></span></code></pre></div><p>¡Una localización que reserva 16 bytes! Agreguemos un nivel más al análisis con <code>-gcflags "-m"</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./main.go:3:6: can inline retString
</span></span><span style=display:flex><span>./main.go:8:6: can inline rePointerToString
</span></span><span style=display:flex><span>./main_test.go:13:16: inlining call to retString
</span></span><span style=display:flex><span>./main_test.go:27:24: inlining call to rePointerToString
</span></span><span style=display:flex><span>./main.go:9:2: moved to heap: retVal
</span></span><span style=display:flex><span>./main_test.go:7:26: leaking param: b
</span></span><span style=display:flex><span>./main_test.go:17:7: ... argument does not escape
</span></span><span style=display:flex><span>./main_test.go:17:8: a escapes to heap
</span></span><span style=display:flex><span>./main_test.go:21:35: leaking param: b
</span></span><span style=display:flex><span>./main_test.go:27:24: moved to heap: retVal
</span></span><span style=display:flex><span>./main_test.go:31:7: ... argument does not escape
</span></span><span style=display:flex><span><span style=color:#75715e># exmem.test</span>
</span></span><span style=display:flex><span>_testmain.go:39:6: can inline init.0
</span></span><span style=display:flex><span>_testmain.go:47:24: inlining call to testing.MainStart
</span></span><span style=display:flex><span>_testmain.go:47:42: testdeps.TestDeps<span style=color:#f92672>{}</span> escapes to heap
</span></span><span style=display:flex><span>_testmain.go:47:24: &amp;testing.M<span style=color:#f92672>{</span>...<span style=color:#f92672>}</span> escapes to heap
</span></span><span style=display:flex><span>goos: linux
</span></span><span style=display:flex><span>goarch: amd64
</span></span><span style=display:flex><span>pkg: exmem
</span></span><span style=display:flex><span>cpu: Intel<span style=color:#f92672>(</span>R<span style=color:#f92672>)</span> Core<span style=color:#f92672>(</span>TM<span style=color:#f92672>)</span> i7-10700 CPU @ 2.90GHz
</span></span><span style=display:flex><span>Benchmark_retPointerToString
</span></span><span style=display:flex><span>Benchmark_retPointerToString-16         <span style=color:#ae81ff>49800909</span>                25.77 ns/op           <span style=color:#ae81ff>16</span> B/op          <span style=color:#ae81ff>1</span> allocs/op
</span></span></code></pre></div><p>Otra vez podemos ver varias cosas interesantes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./main.go:9:2: moved to heap: retVal
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>./main_test.go:17:8: a escapes to heap
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>./main_test.go:27:24: moved to heap: retVal
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>En el archivo <em>main.go</em>, donde definimos la función <code>rePointerToString</code> el análisis de escape nos informa que en la línea 9, donde definimos a la variable <code>retVal</code> como un string, el compilador ha movido la variable al Heap ¡Cuando aún no hemos devuelto su puntero! ¡Lo hacemos recien en la línea 10! ¡Claro! el compilador ha detectado que devolveremos un puntero al valor string almacenado en la variable local, por lo que ha determinado almacenar a la variable en el Heap directamente ¡Aun antes de que se produzca el retorno del puntero!</p><p>Hablar sobre memoria y otros temas relacionados con arquitectura de computadores es apasionante, pero es para nunca terminar.</p><p>Recapitulando, hemos dado un recorrido introductorio a vuelo de pajaro sobre la memoria revisando al Stack y al Heap, con algunos ejemplos en código. Conocimos al flag <code>-gcflags "-m"</code> para agregar análisis de escape a nuestros tests y benchmarks.</p><p>Si le gustó este artículo no olvide compartirlo.</p></section><section class=related><h3>Relacionados</h3><div class=post-list><article class="box box-post"><a class=title href=/posts/2023/12/fuga-de-gorutinas/><h3>Fuga de gorutinas</h3></a><time class=date>December
20
2023</time><div class=summary-container><figure class=post-figure><a href=/posts/2023/12/fuga-de-gorutinas/images/plumbing-pipe-wrench-plumber.jpg><img src=/posts/2023/12/fuga-de-gorutinas/images/plumbing-pipe-wrench-plumber_hu1e3512330b9ca3f140b030a292b63b13_88176_1024x0_resize_q75_box.jpg width=1024 height=683 alt="Fugas. imagen de dominio público gentileza pxfuel. https://www.pxfuel.com/en/free-photo-ojgpw"></a><figcaption>Fugas. imagen de dominio público gentileza pxfuel. https://www.pxfuel.com/en/free-photo-ojgpw</figcaption></figure><p>Sabemos que las gorutinas son una de las mas importantes primitivas que Go pone a nuestra disposición para el manejo de concurrencia. Por eso se hace necesaria una forma de prevenir <em>fugas de gorutinas</em>.</p></div></article><article class="box box-post"><a class=title href=/posts/2023/10/el-tour-de-go-ahora-en-espa%C3%B1ol/><h3>El tour de Go ahora en Español</h3></a><time class=date>October
27
2023</time><div class=summary-container><figure class=post-figure><a href=/posts/2023/10/el-tour-de-go-ahora-en-espa%C3%B1ol/images/tour3.png><img src=/posts/2023/10/el-tour-de-go-ahora-en-espa%C3%B1ol/images/tour3_hu513b247d847e7fe7c11df40df90a15e1_538565_1024x0_resize_box_3.png width=1024 height=1039 alt="Tour de Go en Español"></a><figcaption>Tour de Go en Español</figcaption></figure><p>¡Logramos algo increíble como comunidad!
La traducción del tour de Go al español.
Estamos emocionados de compartir con todos ustedes el increíble logro que hemos alcanzado juntos: la completa traducción del tour de Go al español.</p><p>Este proyecto fue un esfuerzo colaborativo en el que nuestra comunidad contribuyó con su tiempo y conocimiento para hacer que esta herramienta esté disponible para toda la comunidad hispanohablante. ¡El resultado es asombroso!</p></div></article></div></section><section class=comments><h3>Comentar</h3><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//gophers-latam.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></article></main><footer><a href=https://gohugo.io><img src=/img/hugo-logo.svg width=90 height=21></a>
<small>© 2024, Gophers LATAM. - Theme by <a href=https://github.com/zeroidentidad>zeroidentidad</a>.</small></footer></div></body></html>