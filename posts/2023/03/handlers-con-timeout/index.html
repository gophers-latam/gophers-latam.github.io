<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="ZeroIdentidad"><meta name=description content="Gophers LATAM"><meta property="og:image" content="https://gophers-latam.github.io//logo.png"><title>Handlers Con Timeout – Gophers LATAM</title><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.d6650b523f887ec5f48cce44d668be71c5c5848f9fd2147475f139e67395dafb.css><link rel=stylesheet href=/css/syntax.min.f1fef9cbbfe9d2935981821d59853e89db60d137f9117a1279371320195f1d1a.css><link href='https://fonts.googleapis.com/css?family=JetBrains+Mono' rel=stylesheet type=text/css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-192145152-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7766642915413571" crossorigin=anonymous></script></head><body><div class=container><header class="page-header app-width"><div class=header-left><a href=/><img alt="Gophers LATAM" src=/img/gopher.png style=height:90px></a></div><div class=header-center><nav><a href=/>Inicio</a>
<a href=/biografia>Biografía</a>
<a href=/proyectos>Proyectos</a>
<a href=/posts>Posts</a>
<a href=/colaboradores>Colaboradores</a>
<a href=/contacto>Contacto</a></nav></div><div class=header-right><a class=button-search href=/search><img alt=Búsqueda src=/img/search.png></a></div></header><main class=app-width><article class=post><header><h2>Handlers Con Timeout</h2><span class=tags><a class=tag href=/tags/software>software</a>
<a class=tag href=/tags/golang>golang</a></span>
<span class=meta><label>Por: <b>Tomas Lingotti</b></label>
<label>Publicado <b>March 27, 2023</b></label>
<label>Tiempo de lectura: <b>4 minutos</b>.</label></span></header><section class=body><figure class=post-figure><a href=/posts/2023/03/handlers-con-timeout/images/go-handlers.jpeg><img src=/posts/2023/03/handlers-con-timeout/images/go-handlers_hu161c36eb0798f353d6185a69d9318760_46456_1024x0_resize_q75_box.jpeg width=1024 height=568 alt="go handlers"></a><figcaption>go handlers</figcaption></figure><p>En algunas oportunidades, vamos a necesitar un comportamiento <strong>muy</strong> determinístico en nuestras APIs, ya sea porque el negocio así lo requiere o los clientes. Tal vez, un comportamiento que se mantenga alejado de cualquier sorpresa, puede ser el máximo de duración que le queremos dejar como ventana para que un respuesta sea entregada, en caso de excederlo, ahora si como el título lo dice, devolvemos un <strong>timeout</strong>&mldr; pero, qué es un timeout?</p><p>En principio sabemos que contamos con 2 estados para representarlo, pero no se parecen mucho ya que están en <em>centenas</em> distintas, unos es <strong>408 request timeout</strong> y el otro es <strong>504 Gateway timeout</strong>.
Si leemos un poco las especificaciones, ninguno de los dos <em>nos calza justo</em> para lo que queremos, el 408 nos dice que el cliente &ldquo;se tardó demasiado para enviar su request&rdquo;, desde la RFC dice lo siguiente:</p><blockquote><p>The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.</p></blockquote><p>Y para su contraparte del lado del servidor:</p><blockquote><p>The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.</p></blockquote><p>Entonces, para la responder la pregunta, concluimos que un timeout es que esperamos demasiado por algo, y no sucedió, ademas, lo consideramos un error.</p><h2 id=cómo-hacemos-nuestras-funciones-de-timeout>Cómo hacemos nuestras funciones de Timeout?</h2><p>En los lenguajes de programación modernos, encontramos built-in algunas formas de manejar estos casos de uso. En Golang, por ejemplo el paquete <code>context</code> tiene <em>constructores</em> para crear uno que expire y se cancele después de cierto tiempo.</p><p>Dentro del paquete net/http también nos encontramos con muchos timeouts como por ejemplo en la struct <code>http.Client</code> para hacer requests y <code>http.Server</code> es otra que tampoco se queda afuera de tener este tipo de configuración.</p><p>Por ahora, tenemos: context, http.Client y Server, servidores TCP y UDP, etc. Podemos resumir que siempre que haya una conexión hacia fuera (ya sea cliente o servidor) vamos a poder configurar un timeout.</p><h2 id=cómo-nos-sirven-en-los-web-handlers>Cómo nos sirven en los web handlers?</h2><p>Antes, debemos aclarar que es un <strong>middleware</strong>, en cualquier lenguaje, ya que es un concepto y no una implementación específica de Golang.</p><p>Entonces, decimos que son funciones con la misma firma que un handler (o controlador web), que recibe los mismos parámetros para operar como una petición HTTP. Al ser iguales, nos permite ejecutarlo previamente de una forma sencilla y pre-ejecutar operaciones que nos ayuden a nuestro negocio. Un claro ejemplo son validaciones de token JWT, agregar request ID unicos, sumarle datos al contexto (esto si es mas estilo <em>gopher</em>).
En nuestro caso, vamos a tener un middleware que se encargue de reemplazar el contexto, por otro que tenga un timeout, para que no tarde mas de tanto tiempo y si no, falla. Nos va a ayudar a garantizar un tiempo de respuesta de máxima, por las buenas <em>o por las malas</em>.</p><h2 id=lo-llevamos-a-código>Lo llevamos a código</h2><p>Como middleware, podemos usar <em>uno que ya existe</em> y está dentro del paquete http, es <code>http.Timeout</code> y dentro de su firma, vamos a pasarle un <code>http.Handler</code>, <strong>el tiempo de espera que vamos a soportar</strong> y por último (este no me gusta mucho) un mensaje como string, donde nos quita un poco de flexibilidad, a mi entender, <code>[]byte</code> nos daría un espectro mas amplio a la hora de retornar los valores.</p><ul><li>Podemos implementarlo como un wrapper general a todo el multiplexer y que todos ejecuten el middleware, este tiene como ventaja que escribimos una sola vez, pero perdemos granularidad.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mux</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewServeMux</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>//....
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	})
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>muxWithMiddleware</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>TimeoutHandler</span>(<span style=color:#a6e22e>mux</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span><span style=color:#f92672>*</span><span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#34;timeout!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#a6e22e>muxWithMiddleware</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Por último, tenemos otro camino, para tener un control espercífico en cada handler que expongamos.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mux</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewServeMux</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>helloHandler</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>TimeoutHandler</span>(<span style=color:#a6e22e>wrapHandlerFunc</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;hello with timeout!&#34;</span>))
</span></span><span style=display:flex><span>	})), <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span><span style=color:#f92672>*</span><span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>helloHandler</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>wrapHandlerFunc</span>(<span style=color:#a6e22e>handler</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span>) <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wrapped</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Content-Type&#34;</span>, <span style=color:#e6db74>&#34;application/json&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>handler</span>.<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>wrapped</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conclusiones>Conclusiones</h2><p>Vemos la flexibilidad que tenemos para exponer funciones en un servior web que tenemos en Golang. Siempre nos da muchas facilidades y opciones, a su vez, puede ser un poco confuso porque no sabemos bien cual usar. Como pequeño consejo, no nos <em>fritemos</em> la cabeza pensando y comparando, tan solo elijamos una con un análisis superficial y despues nos queda el aprendizaje.</p><p>Para cerrar el tema técnico, estamos re-utilizando una funcion de la stdlib de Go, por lo que no es necesario que nostros pensemos esa lógica, también, muchos de los Frameworks web como Echo, Gin y Fiber (seguramente entre varios otros) ya traen sus middleware de timeout y es de una implementacion muy similar a la que acabamos de ver.</p><p>Espero que les haya gustado la explicación! nos vemos dentro de poco y cualquier tema que quieran que tratemos lo pueden dejar en comentarios.</p></section><section class=related><h3>Relacionados</h3><div class=post-list><article class="box box-post"><a class=title href=/posts/2021/12/ecosistema-lenguage-go/><h3>Ecosistema lenguage Go</h3></a><time class=date>December
27
2021</time><div class=summary-container><figure class=post-figure><a href=/posts/2021/12/ecosistema-lenguage-go/images/golang.png><img src=/posts/2021/12/ecosistema-lenguage-go/images/golang_hu57fed90b28f13fac04b0b2a1fb7dff6d_26167_1024x0_resize_box_3.png width=1024 height=346 alt="json to go"></a><figcaption>json to go</figcaption></figure><p>Go, también conocido como Golang, es un lenguaje de programación de tipado estático desarrollado por Robert Griesemer, Rob Pike y Ken Thompson en Google.</p></div></article><article class="box box-post"><a class=title href=/posts/2022/08/intro-go-mistakes-okno/><h3>Intro Go Mistakes Okno</h3></a><time class=date>August
1
2022</time><div class=summary-container><figure class=post-figure><a href=/posts/2022/08/intro-go-mistakes-okno/images/ok-no.png><img src=/posts/2022/08/intro-go-mistakes-okno/images/ok-no_hu67b008a377f65ecd767073b64a23de40_12277_1024x0_resize_box_3.png width=1024 height=443 alt=okno></a><figcaption>okno</figcaption></figure><p>Se comparte el concepto o contexto de algunos errores basicos con su definición acompañado de ejemplo y solución.</p></div></article><article class="box box-post"><a class=title href=/posts/2021/08/go-talks/><h3>Go Talks</h3></a><time class=date>August
18
2021</time><div class=summary-container><figure class=post-figure><a href=/posts/2021/08/go-talks/images/go-talks.png><img src=/posts/2021/08/go-talks/images/go-talks_hua2212d92c81a395131b43e35903c9f09_241848_1024x0_resize_box_3.png width=1024 height=961 alt=talks></a><figcaption>talks</figcaption></figure><p><a href=https://pkg.go.dev/golang.org/x/talks><img src=https://pkg.go.dev/badge/golang.org/x/talks.svg alt=Reference></a></p><p>Este post contiene charlas de Go que se pueden leer siguiendo los vinculos de cada título listado.</p></div></article><article class="box box-post"><a class=title href=/posts/2021/06/conversi%C3%B3n-json-a-go/><h3>Conversión JSON a Go</h3></a><time class=date>June
5
2021</time><div class=summary-container><figure class=post-figure><a href=/posts/2021/06/conversi%C3%B3n-json-a-go/images/json_to_go.png><img src=/posts/2021/06/conversi%C3%B3n-json-a-go/images/json_to_go_huea8bfa3ec3570bd3e606c0b62bfa85b8_295039_1024x0_resize_box_3.png width=1024 height=768 alt="json to go"></a><figcaption>json to go</figcaption></figure><p>Uno de los formatos de datos que se encuentra con mucha frecuencia en programación, principalmente web, es JavaScript Object Notation (JSON).</p></div></article><article class="box box-post"><a class=title href=/posts/2021/05/golang-implementaci%C3%B3n-del-almacenamiento-en-cach%C3%A9/><h3>Golang: Implementación del almacenamiento en caché</h3></a><time class=date>May
6
2021</time><div class=summary-container><figure class=post-figure><a href=/posts/2021/05/golang-implementaci%C3%B3n-del-almacenamiento-en-cach%C3%A9/images/go-cache.jpg><img src=/posts/2021/05/golang-implementaci%C3%B3n-del-almacenamiento-en-cach%C3%A9/images/go-cache_huddfdaf20a9de86793c7e04ee08a1b995_15138_1024x0_resize_q75_box.jpg width=1024 height=465 alt="go cache"></a><figcaption>go cache</figcaption></figure><p>El almacenamiento en caché de datos en una aplicación web a veces es necesario para evitar solicitar datos estáticos de una base de datos o un servicio externo una y otra vez. Go no proporciona ningún paquete integrado en la librería estándar para almacenar en caché las respuestas, pero lo admite a través de paquetes externos creados por la comunidad.</p></div></article></div></section><section class=comments><h3>Comentar</h3><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//gophers-latam.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></article></main><footer><a href=https://gohugo.io><img src=/img/hugo-logo.svg width=90 height=21></a>
<small>© 2023, Gophers LATAM. - Theme by <a href=https://github.com/zeroidentidad>zeroidentidad</a>.</small></footer></div></body></html>